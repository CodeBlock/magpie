// TODO(bob): Note, there's something gross here. Multimethods are currently
// always defined in the top global scope, so these will hang around after the
// test completes. Need locally scoped multimethods.

specify("A multimethod") with
    defineMethod("multi1", fn(a Int) "int")
    defineMethod("multi1", fn(a String) "str")

    defineMethod("multi2", fn(a Int, b Int) "int int")
    defineMethod("multi2", fn(a Int, b String) "int str")
    defineMethod("multi2", fn(a String, b Int) "str int")
    defineMethod("multi2", fn(a String, b String) "str str")

    it should("select a method that matches the argument type") with
        multi1(123) shouldBe("int")
        multi1("s") shouldBe("str")
    end

    it should("select a method based on tuple field types") with
        multi2(123, 123) shouldBe("int int")
        multi2(123, "s") shouldBe("int str")
        multi2("s", 123) shouldBe("str int")
        multi2("s", "s") shouldBe("str str")
    end

    it should("throw an error if no method matches") with
        fn
            multi1(true)
        end shouldThrow(NoMethodError)
    end
end

// TODO(bob): Hack. Declared at top scope because multimethods evaluate method
// types in global scope.
//  A1 A2
//  | \ |
//  B1 B2
//  |
//  C1

class A1
end

class A2
end

class B1
    inherit(A1)
end

class B2
    inherit(A1)
    inherit(A2)
end

class C1
    inherit(B1)
end

class Foo
    get prop = "prop"
end

specify("The linearization of a multimethod") with
    defineMethod("linear1", fn(a B1) "b1")
    defineMethod("linear1", fn(a A1) "a1")
    defineMethod("linear1", fn(a C1) "c1")

    defineMethod("linear2", fn(a String) "class")
    defineMethod("linear2", fn("string") "value")
    defineMethod("linear2", fn(123) "value")
    defineMethod("linear2", fn(a Int) "class")

    defineMethod("linear3", fn(a String) "class")
    defineMethod("linear3", fn(anything) "any")
    defineMethod("linear3", fn(a Int) "class")

    defineMethod("linear4", fn("string") "value")
    defineMethod("linear4", fn(anything) "any")
    defineMethod("linear4", fn(123) "value")

    defineMethod("linear5", fn(foo: _) "record")
    defineMethod("linear5", fn(foo Foo) "class")
    defineMethod("linear5", fn(foo: _, bar: _) "record")

    it should("prefer the most-derived class") with
        linear1(A1 new()) shouldBe("a1")
        linear1(B1 new()) shouldBe("b1")
        linear1(B2 new()) shouldBe("a1")
        linear1(C1 new()) shouldBe("c1")
    end

    it should("prefer a value over a class") with
        linear2("string") shouldBe("value")
        linear2(123) shouldBe("value")
    end

    it should("prefer a class over an untyped variable") with
        linear3("string") shouldBe("class")
        linear3(123) shouldBe("class")
    end

    it should("prefer a value over an untyped variable") with
        linear4("string") shouldBe("value")
        linear4(123) shouldBe("value")
    end

    it should("prefer a class over a record") with
        linear5(Foo new()) shouldBe("class")
    end
end