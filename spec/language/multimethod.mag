// TODO(bob): Note, there's something gross here. Multimethods are currently
// always defined in the top global scope, so these will hang around after the
// test completes. Need locally scoped multimethods.

specify("A multimethod") with
    defmethod multi1(a Int)
        "int"
    end

    defmethod multi1(a String)
        "str"
    end

    defmethod multi2(a Int, b Int)
        "int int"
    end

    defmethod multi2(a Int, b String)
        "int str"
    end

    defmethod multi2(a String, b Int)
        "str int"
    end

    defmethod multi2(a String, b String)
        "str str"
    end

    it should("select a method that matches the argument type") with
        multi1(123) shouldBe("int")
        multi1("s") shouldBe("str")
    end

    it should("select a method based on tuple field types") with
        multi2(123, 123) shouldBe("int int")
        multi2(123, "s") shouldBe("int str")
        multi2("s", 123) shouldBe("str int")
        multi2("s", "s") shouldBe("str str")
    end

    it should("throw an error if no method matches") with
        fn
            multi1(true)
        end shouldThrow(NoMethodError)
    end
end

// TODO(bob): Hack. Declared at top scope because multimethods evaluate method
// types in global scope.
//  A1 A2
//  | \ |
//  B1 B2
//  |
//  C1

class A1
end

class A2
end

class B1 : A1
end

class B2 : A1, A2
end

class C1 : B1
end

class Foo
    get prop = "prop"
end

specify("The linearization of a multimethod") with
    defmethod linear1(a B1)
        "b1"
    end

    defmethod linear1(a A1)
        "a1"
    end

    defmethod linear1(a C1)
        "c1"
    end

    defmethod linear2(a String)
        "class"
    end

    defmethod linear2("string")
        "value"
    end

    defmethod linear2(123)
        "value"
    end

    defmethod linear2(a Int)
        "class"
    end

    defmethod linear3(a String)
        "class"
    end

    defmethod linear3(anything)
        "any"
    end

    defmethod linear3(a Int)
        "class"
    end

    defmethod linear4("string")
        "value"
    end

    defmethod linear4(anything)
        "any"
    end

    defmethod linear4(123)
        "value"
    end

    defmethod linear5(foo: _)
        "record"
    end

    defmethod linear5(foo Foo)
        "class"
    end

    defmethod linear5(foo: _, bar: _)
        "record"
    end

    defmethod linear6(a A1, b A1)
        "a1 a1"
    end

    defmethod linear6(a B1, b A1)
        "b1 a1"
    end

    defmethod linear6(a B1, b B1)
        "b1 b1"
    end

    defmethod linear7(a B1, b A1)
        "b1 a1"
    end

    defmethod linear7(a A1, b B1)
        "a1 b1"
    end

    it should("prefer the most-derived class") with
        linear1(A1 new()) shouldBe("a1")
        linear1(B1 new()) shouldBe("b1")
        linear1(B2 new()) shouldBe("a1")
        linear1(C1 new()) shouldBe("c1")
    end

    it should("prefer a value over a class") with
        linear2("string") shouldBe("value")
        linear2(123) shouldBe("value")
    end

    it should("prefer a class over an untyped variable") with
        linear3("string") shouldBe("class")
        linear3(123) shouldBe("class")
    end

    it should("prefer a value over an untyped variable") with
        linear4("string") shouldBe("value")
        linear4(123) shouldBe("value")
    end

    // TODO(bob): Implement me!
    /*
    it should("prefer a class over a record") with
        linear5(Foo new()) shouldBe("class")
    end
    */

    it should("order tuples by their fields") with
        linear6(A1 new(), A1 new()) shouldBe("a1 a1")
        linear6(C1 new(), A1 new()) shouldBe("b1 a1")
        linear6(A1 new(), C1 new()) shouldBe("a1 a1")
        linear6(C1 new(), C1 new()) shouldBe("b1 b1")
    end

    it should("be ambiguous if tuple fields don't agree") with
        fn
            linear7(B1 new(), B1 new())
        end shouldThrow(AmbiguousMethodError)
    end
end