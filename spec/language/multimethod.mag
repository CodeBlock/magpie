// TODO(bob): Note, there's something gross here. Multimethods are currently
// always defined in the top global scope, so these will hang around after the
// test completes. Need locally scoped multimethods.

specify("A multimethod") with
    def multi1(a Int) -> "int"
    def multi1(a String) -> "str"
    def multi2(a Int, b Int) -> "int int"
    def multi2(a Int, b String) -> "int str"
    def multi2(a String, b Int) -> "str int"
    def multi2(a String, b String) -> "str str"

    it should("select a method that matches the argument type") with
        multi1(123) shouldEqual("int")
        multi1("s") shouldEqual("str")
    end

    it should("select a method based on tuple field types") with
        multi2(123, 123) shouldEqual("int int")
        multi2(123, "s") shouldEqual("int str")
        multi2("s", 123) shouldEqual("str int")
        multi2("s", "s") shouldEqual("str str")
    end

    it should("throw an error if no method matches") with
        fn
            multi1(true)
        end shouldThrow(NoMethodError)
    end
end

specify("The linearization of a multimethod") with

    //  A1 A2
    //  | \ |
    //  B1 B2
    //  |
    //  C1

    defclass A1
    end

    defclass A2
    end

    defclass B1 : A1
    end

    defclass B2 : A1, A2
    end

    defclass C1 : B1
    end

    defclass Foo
    end

    def (this Foo) prop -> "prop"

    def linear1(a B1) -> "b1"
    def linear1(a A1) -> "a1"
    def linear1(a C1) -> "c1"
    def linear2(a String) -> "class"
    def linear2("string") -> "value"
    def linear2(123) -> "value"
    def linear2(a Int) -> "class"
    def linear3(a String) -> "class"
    def linear3(anything) -> "any"
    def linear3(a Int) -> "class"
    def linear4("string") -> "value"
    def linear4(anything) -> "any"
    def linear4(123) -> "value"
    def linear5(foo: _) -> "record"
    def linear5(foo Foo) -> "class"
    def linear5(foo: _, bar: _) -> "record"
    def linear6(a A1, b A1) -> "a1 a1"
    def linear6(a B1, b A1) -> "b1 a1"
    def linear6(a B1, b B1) -> "b1 b1"
    def linear7(a B1, b A1) -> "b1 a1"
    def linear7(a A1, b B1) -> "a1 b1"

    it should("prefer the most-derived class") with
        linear1(A1 new()) shouldEqual("a1")
        linear1(B1 new()) shouldEqual("b1")
        linear1(B2 new()) shouldEqual("a1")
        linear1(C1 new()) shouldEqual("c1")
    end

    it should("prefer a value over a class") with
        linear2("string") shouldEqual("value")
        linear2(123) shouldEqual("value")
    end

    it should("prefer a class over an untyped variable") with
        linear3("string") shouldEqual("class")
        linear3(123) shouldEqual("class")
    end

    it should("prefer a value over an untyped variable") with
        linear4("string") shouldEqual("value")
        linear4(123) shouldEqual("value")
    end

    // TODO(bob): Implement me!
    /*
    it should("prefer a class over a record") with
        linear5(Foo new()) shouldEqual("class")
    end
    */

    it should("order tuples by their fields") with
        linear6(A1 new(), A1 new()) shouldEqual("a1 a1")
        linear6(C1 new(), A1 new()) shouldEqual("b1 a1")
        linear6(A1 new(), C1 new()) shouldEqual("a1 a1")
        linear6(C1 new(), C1 new()) shouldEqual("b1 b1")
    end

    it should("be ambiguous if tuple fields don't agree") with
        fn
            linear7(B1 new(), B1 new())
        end shouldThrow(AmbiguousMethodError)
    end
end