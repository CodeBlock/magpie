// TODO(bob): Note, there's something gross here. Multimethods are currently
// always defined in the top global scope, so these will hang around after the
// test completes. Need locally scoped multimethods.

specify("A multimethod") with
    defmethod multi1(a Int) "int"
    defmethod multi1(a String) "str"
    defmethod multi2(a Int, b Int) "int int"
    defmethod multi2(a Int, b String) "int str"
    defmethod multi2(a String, b Int) "str int"
    defmethod multi2(a String, b String) "str str"

    it should("select a method that matches the argument type") with
        multi1(123) shouldEqual("int")
        multi1("s") shouldEqual("str")
    end

    it should("select a method based on tuple field types") with
        multi2(123, 123) shouldEqual("int int")
        multi2(123, "s") shouldEqual("int str")
        multi2("s", 123) shouldEqual("str int")
        multi2("s", "s") shouldEqual("str str")
    end

    it should("throw an error if no method matches") with
        fn
            multi1(true)
        end shouldThrow(NoMethodError)
    end
end

// TODO(bob): Hack. Declared at top scope because multimethods evaluate method
// types in global scope.
//  A1 A2
//  | \ |
//  B1 B2
//  |
//  C1

class A1
end

class A2
end

class B1 : A1
end

class B2 : A1, A2
end

class C1 : B1
end

class Foo
    get prop = "prop"
end

specify("The linearization of a multimethod") with
    defmethod linear1(a B1) "b1"
    defmethod linear1(a A1) "a1"
    defmethod linear1(a C1) "c1"
    defmethod linear2(a String) "class"
    defmethod linear2("string") "value"
    defmethod linear2(123) "value"
    defmethod linear2(a Int) "class"
    defmethod linear3(a String) "class"
    defmethod linear3(anything) "any"
    defmethod linear3(a Int) "class"
    defmethod linear4("string") "value"
    defmethod linear4(anything) "any"
    defmethod linear4(123) "value"
    defmethod linear5(foo: _) "record"
    defmethod linear5(foo Foo) "class"
    defmethod linear5(foo: _, bar: _) "record"
    defmethod linear6(a A1, b A1) "a1 a1"
    defmethod linear6(a B1, b A1) "b1 a1"
    defmethod linear6(a B1, b B1) "b1 b1"
    defmethod linear7(a B1, b A1) "b1 a1"
    defmethod linear7(a A1, b B1) "a1 b1"

    it should("prefer the most-derived class") with
        linear1(A1 new()) shouldEqual("a1")
        linear1(B1 new()) shouldEqual("b1")
        linear1(B2 new()) shouldEqual("a1")
        linear1(C1 new()) shouldEqual("c1")
    end

    it should("prefer a value over a class") with
        linear2("string") shouldEqual("value")
        linear2(123) shouldEqual("value")
    end

    it should("prefer a class over an untyped variable") with
        linear3("string") shouldEqual("class")
        linear3(123) shouldEqual("class")
    end

    it should("prefer a value over an untyped variable") with
        linear4("string") shouldEqual("value")
        linear4(123) shouldEqual("value")
    end

    // TODO(bob): Implement me!
    /*
    it should("prefer a class over a record") with
        linear5(Foo new()) shouldEqual("class")
    end
    */

    it should("order tuples by their fields") with
        linear6(A1 new(), A1 new()) shouldEqual("a1 a1")
        linear6(C1 new(), A1 new()) shouldEqual("b1 a1")
        linear6(A1 new(), C1 new()) shouldEqual("a1 a1")
        linear6(C1 new(), C1 new()) shouldEqual("b1 b1")
    end

    it should("be ambiguous if tuple fields don't agree") with
        fn
            linear7(B1 new(), B1 new())
        end shouldThrow(AmbiguousMethodError)
    end
end