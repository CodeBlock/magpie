specify("A 'match' expression") with
    it should("evaluate the value expression once") with
        var called = 0
        def eval()
            called = called + 1
            "value"
        end
        
        match eval()
            case "a" then "one"
            case "b" then "two"
            else "three"
        end
        
        called shouldBe(1)
    end
    
    it should("return the value of the matched case") with
        match 2
            case 1 then "one"
            case 2 then "two"
            case 3 then "three"
        end shouldBe("two")
    end

    it should("only evaluate the first matched case") with
        var called = ""
        match true
            case true then called = called ~ "1"
            case true then called = called ~ "2"
        end
        called shouldBe("1")
    end

    it should("throw an error if no case matches") with
        fn
            match "not found"
                case "a" then "bad"
                case "b" then "bad"
            end
        end shouldThrow(NoMatchError)
    end

    it should("match an else case if nothing else matches") with
        match "not found"
            case "a" then "bad"
            case "b" then "bad"
            else "good"
        end shouldBe("good")
    end
    
    it should("bind a variable to the matched value") with
        match 1
            case a 1 then a
        end shouldBe(1)
    end
    
    it should("scope a binding to just the matched case") with
        var a = "outer"
        match "match"
            case a "match" then a = "inner"
        end
        a shouldBe("outer")
    end
end

specify("A tuple pattern") with
    it should("match against all fields") with
        match 1, 2
            case 1, 3 then "no"
            case 3, 2 then "no"
            case 1, 2 then "yes"
        end shouldBe("yes")
    end

    it should("bind a variable to a field") with
        match "one", ("two", "three")
            case a, (b, c) then a ~ b ~ c
        end shouldBe("onetwothree")
    end
end

specify("A primary pattern") with
    it should("match a wildcard") with
        match "whatever"
            case _      then "yes"
            case "else" then "no"
        end shouldBe("yes")
    end
    
    it should("match a variable binding") with
        match "whatever"
            case a      then "yes"
            case "else" then "no"
        end shouldBe("yes")
    end
    
    it should("match a literal bool value") with
        match true
            case true then "yes"
            case false then "no"
        end shouldBe("yes")
    end

    it should("match a literal int value") with
        match 2
            case 1 then "no"
            case 2 then "yes"
        end shouldBe("yes")
    end

    it should("match a literal string value") with
        match "a"
            case "a" then "yes"
            case "b" then "no"
        end shouldBe("yes")
    end

    it should("match a class object as a value") with
        match Int
            case Bool then "no"
            case Int then "yes"
        end shouldBe("yes")
    end

    it should("match against the value's type using a wildcard") with
        match 123
            case _ Bool then "no"
            case _ Int then "yes"
        end shouldBe("yes")
    end

    it should("match against the value's type using a name") with
        match 123
            case a Bool then "no"
            case a Int then "yes"
        end shouldBe("yes")
    end
end

specify("The grammar for a 'match' expression") with
    it should("allow a block for a case body") with
        var result = ""
        match "first"
            case "first" then
                result = "a"
                result = result ~ "b"
            case "second" then
                result = "bad"
                result = result ~ "d"
            end
        end
        result shouldBe("ab")
    end

    it should("allow a block for the else body") with
        var result = ""
        match "second"
            case "first" then
            else
                result = "a"
                result = result ~ "b"
            end
        end
        result shouldBe("ab")
    end
end