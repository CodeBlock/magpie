// magpie.core is automatically loaded and imported into every module before it
// is run.
import magpie.reflect sameAs?
import magpie.syntax

// TODO(bob): This file is getting kind of massive. Need to figure out how to
// have multiple sources files define a single logical module. Maybe just an
// easy way to re-export an imported name.

import classfile:com.stuffwithstuff.magpie.interpreter.builtin.BuiltInFunctions
import classfile:com.stuffwithstuff.magpie.interpreter.builtin.ClassBuiltIns
import classfile:com.stuffwithstuff.magpie.interpreter.builtin.FunctionBuiltIns
import classfile:com.stuffwithstuff.magpie.interpreter.builtin.IntBuiltIns
import classfile:com.stuffwithstuff.magpie.interpreter.builtin.ListBuiltIns
import classfile:com.stuffwithstuff.magpie.interpreter.builtin.ObjectBuiltIns
import classfile:com.stuffwithstuff.magpie.interpreter.builtin.StringBuiltIns

// Note: This file is parsed before any arithmetic operator syntax has been
// defined, which is why it calls them in regular message for like 1+(2).

// String conversion for core classes
// ----------------------------------------------------------------------------

def (this is String) string
    this
end

def (nothing) string
    "nothing"
end

def (true) string
    "true"
end

def (false) string
    "false"
end

def (this is Class) string
    this name
end

def print()
    /// Prints a newline to standard output.
    prints("\n")
end

def print(text is String)
    /// Prints *text* to standard output.
    prints(text +("\n"))
end

def print(any)
    /// Converts *any* to a string and prints it to standard output.
    print(any string)
end

def not(true)
    /// Returns `false`.
    false
end

def not(false)
    /// Returns `true`.
    true
end

// By default, == just does identity comparison.
def (this) == (that)
    this sameAs?(that)
end

def (this) != (that)
    not(this ==(that))
end

def (this) + (that)
    (this string) +(that string)
end

// Truthiness.
def (this) true?
    true
end

def (this is Bool) true?
    this
end

def (this is Int) true?
    this !=(0)
end

def (this is String) true?
    this count >(0)
end

def (nothing) true?
    false
end

// Implement comparison in terms of a master compareTo() method.
def (this is Comparable) < (that is Comparable)
    this compareTo(that) ==(-1)
end

def (this is Comparable) > (that is Comparable)
    this compareTo(that) ==(1)
end

def (this is Comparable) <= (that is Comparable)
    this compareTo(that) !=(1)
end

def (this is Comparable) >= (that is Comparable)
    this compareTo(that) !=(-1)
end

// Ranges and indexable iteration.
def (this is Indexable) iterate()
    IndexableIterator new(indexable: this)
end

def (this is Indexable) validateIndex(index is Int)
    // Negative indexes count from the back.
    index = match index <(0)
        case true then this count +(index)
        else index
    end

    // Check the bounds.
    match index <(0)
        case true then throw OutOfBoundsError new()
        else nothing
    end

    match index >=(this count)
        case true then throw OutOfBoundsError new()
        else nothing
    end

    // Return the updated index.
    index
end

defclass IndexableIterator
    /// An iterator that can iterator over any class that inherits from
    /// Indexable and provides a "count" getter, and a numeric indexer.
    var indexable is Indexable
    var index     = -1
end

def (this is IndexableIterator) next()
    this index = this index +(1)
    this index <(this indexable count)
end

def (this is IndexableIterator) current
    this indexable[this index]
end


defclass Range is Indexable
    /// An Indexable, iterable range of sequential integers from a given
    /// *first* to *last* (inclusive).
    var first is Int
    var last  is Int
end

def (this is Range)[index is Int]
    index = this validateIndex(index)
    this first +(index)
end

def (this is Range) count
    (this last -(this first)) +(1)
end

def (this is Int) to(last is Int)
    Range new(first: this, last: last)
end

// "and" Parser
// ----------------------------------------------------------------------------

defineInfix("and", 3, fn(parser is Parser, left is Expression, token is Token)
    // Ignore a newline after "and".
    parser matchToken(TokenType.LINE)
    var right = parser parseExpression(3)
    {
        do
            // TODO(bob): Use generated symbol.
            var temp__ = `left
            match temp__ true?
                case true then `right
                else temp__
            end
        end
    }
end)

// "or" Parser
// ----------------------------------------------------------------------------

defineInfix("or", 3, fn(parser is Parser, left is Expression, token is Token)
    // Ignore a newline after "or".
    parser matchToken(TokenType.LINE)
    var right = parser parseExpression(3)
    {
        do
            // TODO(bob): Use generated symbol.
            var temp__ = `left
            match temp__ true?
                case true then temp__
                else `right
            end
        end
    }
end)

// If expression
// ----------------------------------------------------------------------------

definePrefix("if", fn(parser is Parser, token is Token)
    // Parse the condition.
    var condition, _ = parser parseExpressionOrBlock(["then"])

    // Parse the then body.
    parser consume("then")
    var thenExpr, endToken = parser parseExpressionOrBlock(["else", "end"])

    // Don't try to parse "else" if we got an explicit "end" for the "then"
    // block.
    var consumedEnd? = match endToken
        case nothing then false
        case token then
            match token type name
                case "NAME" then token value ==("end")
                else false
            end
        end
    end

    // See if we have an "else" keyword.
    var parsedElse? = match consumedEnd?
        case true then false
        case false then parser matchToken("else")
    end

    // Parse the "else" expression if there otherwise use nothing.
    var elseExpr = match parsedElse?
        case true then parser parseExpressionOrBlock()
        else { nothing }
    end

    // Desugar to a match.
    {
        match `condition true?
            case true then `thenExpr
            else `elseExpr
        end
    }
end)

// Infix arithmetic operators
// ----------------------------------------------------------------------------

def _makeOperator(name is String, stickiness is Int)
    defineInfix(name, stickiness,
        fn(parser is Parser, left is Expression, token is Token)
            // Ignore a newline after operator.
            parser matchToken(TokenType.LINE)
            var right = parser parseExpression(stickiness)
            CallExpression new(Expression: (position: token position),
                receiver: left, name: name, argument: right)
        end
    )
end

_makeOperator("*", 8)
_makeOperator("/", 8)
_makeOperator("%", 8)
_makeOperator("+", 7)
_makeOperator("-", 7)
_makeOperator("<", 5)
_makeOperator(">", 5)
_makeOperator("<=", 5)
_makeOperator(">=", 5)
_makeOperator("==", 4)
_makeOperator("!=", 4)

// "definfix" Parser and core operators
// ----------------------------------------------------------------------------

/*
definePrefix("definfix", fn(parser is Parser, token is Token)
    // Keyword for parsing an infix operator with a given name and stickiness.
    // Simply desugars to a call a function with the same name:
    //
    //     definfix + 5
    //     // from:
    //     a +% b
    //     // to:
    //     a +%(b)
    var name = parser consume(TokenType.NAME) value
    var stickiness = parser consume(TokenType.INT) value

    {
        defineInfix(`name, `stickiness,
            fn(parser is Parser, left is Expression, token is Token)
                // Ignore a newline after operator.
                parser matchToken(TokenType.LINE)
                var right = parser parseExpression(`stickiness)
                CallExpression new(Expression: (position: token position),
                    receiver: left, name: `name, argument: right)
            end
        )
    }
end)

*/