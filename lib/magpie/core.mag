// magpie.core is automatically loaded and imported into every module before it
// is run.
import magpie.reflect sameAs?
import magpie.syntax

// TODO(bob): This file is getting kind of massive. Need to figure out how to
// have multiple sources files define a single logical module. Maybe just an
// easy way to re-export an imported name.

import classfile:com.stuffwithstuff.magpie.interpreter.builtin.BuiltInFunctions
import classfile:com.stuffwithstuff.magpie.interpreter.builtin.ClassBuiltIns
import classfile:com.stuffwithstuff.magpie.interpreter.builtin.FunctionBuiltIns
import classfile:com.stuffwithstuff.magpie.interpreter.builtin.IntBuiltIns
import classfile:com.stuffwithstuff.magpie.interpreter.builtin.ListBuiltIns
import classfile:com.stuffwithstuff.magpie.interpreter.builtin.ObjectBuiltIns
import classfile:com.stuffwithstuff.magpie.interpreter.builtin.StringBuiltIns

// Note: This file is parsed before any arithmetic operator syntax has been
// defined, which is why it calls them in regular message for like 1+(2).

// String conversion for core classes
// ----------------------------------------------------------------------------

def (this is String) string
    this
end

def (nothing) string
    "nothing"
end

def (true) string
    "true"
end

def (false) string
    "false"
end

def (this is Class) string
    this name
end

def print()
    /// Prints a newline to standard output.
    prints("\n")
end

def print(text is String)
    /// Prints *text* to standard output.
    prints(text +("\n"))
end

def print(any)
    /// Converts *any* to a string and prints it to standard output.
    print(any string)
end

def not(true)
    /// Returns `false`.
    false
end

def not(false)
    /// Returns `true`.
    true
end

// By default, == just does identity comparison.
def (this) == (that)
    this sameAs?(that)
end

def (this) != (that)
    not(this ==(that))
end

def (this) + (that)
    (this string) +(that string)
end

// Truthiness.
def (this) true?
    true
end

def (this is Bool) true?
    this
end

def (this is Int) true?
    this !=(0)
end

def (this is String) true?
    this count >(0)
end

def (nothing) true?
    false
end

// Implement comparison in terms of a master compareTo() method.
def (this is Comparable) < (that is Comparable)
    this compareTo(that) ==(-1)
end

def (this is Comparable) > (that is Comparable)
    this compareTo(that) ==(1)
end

def (this is Comparable) <= (that is Comparable)
    this compareTo(that) !=(1)
end

def (this is Comparable) >= (that is Comparable)
    this compareTo(that) !=(-1)
end

// Ranges and indexable iteration.
def (this is Indexable) iterate()
    IndexableIterator new(indexable: this)
end

def (this is Indexable) validateIndex(index is Int)
    // Negative indexes count from the back.
    if index <(0) then index = this count +(index)

    // Check the bounds.
    if index <(0) then throw OutOfBoundsError new()
    if index >=(this count) then throw OutOfBoundsError new()

    // Return the updated index.
    index
end

defclass IndexableIterator
    /// An iterator that can iterator over any class that inherits from
    /// Indexable and provides a "count" getter, and a numeric indexer.
    var indexable is Indexable
    var index     = -1
end

def (this is IndexableIterator) next()
    this index = this index +(1)
    this index <(this indexable count)
end

def (this is IndexableIterator) current
    this indexable[this index]
end


defclass Range is Indexable
    /// An Indexable, iterable range of sequential integers from a given
    /// *first* to *last* (inclusive).
    var first is Int
    var last  is Int
end

def (this is Range)[index is Int]
    index = this validateIndex(index)
    this first +(index)
end

def (this is Range) count
    (this last -(this first)) +(1)
end

def (this is Int) to(last is Int)
    Range new(first: this, last: last)
end

// "and" Parser
// ----------------------------------------------------------------------------

// TODO(bob): Move into its own module.
defineInfix("and", 3, fn(parser is Parser, left is Expression, token is Token)
    // Ignore a newline after "and".
    parser matchToken(TokenType.LINE)
    var right = parser parseExpression(3)
    {
        do
            // TODO(bob): Use generated symbol.
            var temp__ = `left
            match temp__ true?
                case true then `right
                else temp__
            end
        end
    }
end)

// "or" Parser
// ----------------------------------------------------------------------------

// TODO(bob): Move into its own module.
defineInfix("or", 3, fn(parser is Parser, left is Expression, token is Token)
    // Ignore a newline after "or".
    parser matchToken(TokenType.LINE)
    var right = parser parseExpression(3)
    {
        do
            // TODO(bob): Use generated symbol.
            var temp__ = `left
            match temp__ true?
                case true then temp__
                else `right
            end
        end
    }
end)

// Infix arithmetic operators
// ----------------------------------------------------------------------------

def _makeOperator(name is String, stickiness is Int)
    defineInfix(name, stickiness,
        fn(parser is Parser, left is Expression, token is Token)
            // Ignore a newline after operator.
            parser matchToken(TokenType.LINE)
            var right = parser parseExpression(stickiness)
            CallExpression new(Expression: (position: token position),
                receiver: left, name: name, argument: right)
        end
    )
end

_makeOperator("*", 8)
_makeOperator("/", 8)
_makeOperator("%", 8)
_makeOperator("+", 7)
_makeOperator("-", 7)
_makeOperator("<", 5)
_makeOperator(">", 5)
_makeOperator("<=", 5)
_makeOperator(">=", 5)
_makeOperator("==", 4)
_makeOperator("!=", 4)
