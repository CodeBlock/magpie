
        <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
        <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
        <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
        <title>Magpie: Expression Objects</title>
        <link rel="stylesheet" type="text/css"
          href="http://fonts.googleapis.com/css?family=Reenie+Beanie|Droid+Sans+Mono">
        <link rel="stylesheet" type="text/css" href="../../style.css" />
        </head>
        <body>
<div class="content">
  <h2>
    <table>
      <tr>
        <td>&lsaquo; <a href="../../language.html">Previous</a></td>
        <td><a href="../../language.html">Magpie Guide</a> / <a href="../../language.html">Language</a> / <a href="../objects.html">Objects</a> / Expression Objects
        </td>
        <td><a href="../../language.html">Next</a> &rsaquo;</td>
      </tr>
    </table></h2>
    <h1>Expression Objects</h1>
              <p>Metaprogramming is writing code that operates on objects that themselves
represent code. In other words: programs that write programs. Think of it as
software navel-gazing. Like any powerful tool, metaprogramming can be used to
obscure, mystify, and cause harm. But in the hands of the benevolent, it can be
a useful and expressive feature.</p>
<p>Every language supports metaprogramming to some degree or another. You can write
a C program that manipulates another C program as a string if you really want to. The question is how easy it is to do.</p>
<p>Magpie tries to make it easier by defining expressions classes in the standard library for representing chunks of Magpie code, and because it has <em>expression literals</em>: a concise syntax for creating instances of those classes.</p>
<h3>Expression Classes</h3>
<p>In the Magpie base library are a set of expression classes. Each class represents a different kind of built-in expression in the Magpie syntax. For example, an instance of <code>VarExpression</code> represents a variable declaration expression. It has fields for the name of the variable and the expression used to initialize it. You can create an instance of it like you would any other object:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="n">expression</span> <span class="err">=</span> <span class="n">VarExpression</span> <span class="n">new</span><span class="p">(</span><span class="s">&quot;age&quot;</span><span class="p">,</span> <span class="n">IntExpression</span> <span class="n">new</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span>
</pre></div>


<p>This will create an object that represents the chunk of code <code>var age = 32</code>.
Since everything in Magpie is an expression, you can use these classes to
construct objects that represent entire Magpie programs. You can pull apart, compose and otherwise play with code using these, just like any other data structure.</p>
<p class="future">
The full set of expression classes will be documented with the standard lib at
some point.
</p>

<h3>Expression Literals</h3>
<p>By itself though, this isn't really usable. This chunk of code:</p>
<div class="codehilite"><pre><span class="n">VarExpression</span> <span class="n">new</span><span class="p">(</span><span class="s">&quot;age&quot;</span><span class="p">,</span> <span class="n">IntExpression</span> <span class="n">new</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span>
</pre></div>


<p>doesn't look very much like the code it represents:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="n">age</span> <span class="err">=</span> <span class="mi">32</span>
</pre></div>


<p>To fix that, Magpie supports <em>expression literals</em>. An expression literal is a chunk of code surrounded by curly braces. When evaluated, instead of evaluating that code directly, it just creates an expression object that represents the code. In other words, these two lines of code are equivalent:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="n">expr</span> <span class="err">=</span> <span class="n">VarExpression</span> <span class="n">new</span><span class="p">(</span><span class="s">&quot;age&quot;</span><span class="p">,</span> <span class="n">IntExpression</span> <span class="n">new</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span>
<span class="k">var</span> <span class="n">expr</span> <span class="err">=</span> <span class="p">{</span> <span class="k">var</span> <span class="n">age</span> <span class="err">=</span> <span class="mi">32</span> <span class="p">}</span>
</pre></div>


<p>After evaluating an expression literal, you can treat the result like any regular object. For example:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="n">expr</span> <span class="err">=</span> <span class="p">{</span> <span class="k">var</span> <span class="n">someVariable</span> <span class="err">=</span> <span class="s">&quot;the value&quot;</span> <span class="p">}</span>
<span class="n">print</span><span class="p">(</span><span class="n">expr</span> <span class="n">name</span><span class="p">)</span> <span class="c1">// prints &quot;someVariable&quot;</span>
</pre></div>


<h3>Quasiquoting</h3>
<p>This gets us a lot farther. Now we've got a pretty simple syntax to build chunks
of fixed code, but what if the code objects we're building have parts that vary?
What if you want to do:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="n">expr</span> <span class="err">=</span> <span class="p">{</span> <span class="k">var</span> <span class="n">age</span> <span class="err">=</span> <span class="mi">32</span> <span class="p">}</span>
</pre></div>


<p>But instead of always initializing <code>age</code> to <code>32</code>, you want to be able to vary
that value? To address that, expression literals support <em>quasiquoting</em>. Quasiquoting is very similar to string interpolation. The basic idea is that within a syntax literal, you can indicate an expression that should be <em>evaluated</em> right then instead of just treated like a chunk of code. For example:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="n">age</span> <span class="err">=</span> <span class="p">{</span> <span class="mi">23</span> <span class="p">}</span>
<span class="k">var</span> <span class="n">expr</span> <span class="err">=</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;You are &quot;</span> <span class="err">~</span> <span class="err">`</span><span class="n">age</span> <span class="err">~</span> <span class="s">&quot; years old!&quot;</span><span class="p">)</span> <span class="p">}</span>
</pre></div>


<p>The backtick (<code>`</code>) character there tells Magpie that the following expression should be evaluated in place. In other words, the value of <code>expr</code> will be an object that represents the chunk of code:</p>
<div class="codehilite"><pre><span class="n">print</span><span class="p">(</span><span class="s">&quot;You are &quot;</span> <span class="err">~</span> <span class="mi">23</span> <span class="err">~</span> <span class="s">&quot; years old!&quot;</span><span class="p">)</span>
</pre></div>


<p>The value of the <code>age</code> variable has been inserted into our expression literal.</p>
<p>It's important to note that the value of <code>age</code> was itself an expression&mdash; <code>{ 23 }</code>&mdash; and not just the raw number <code>23</code>. That's because we're inserting an <em>expression</em> into our expression literal, not a <em>value</em>. The <em>number</em> 23 isn't a valid expression object in Magpie (though it is a valid expression, and a valid object!). If you want an expression representing the <em>literal</em> 23, you need an instance of <code>IntExpression</code>, which is what <code>{ 23 }</code> will evaluate to.</p>
<p>It's a bit confusing, I'll admit. The short summary is that when you use quasiquoting, the values you insert will always need to be an instance of one of the expression types.</p>
<h3>Quasiquote Expressions</h3>
<p>There are a couple of ways you can quasiquote inside an expression. The simplest one we have already seen: you can follow the backtick immediately with a name:</p>
<div class="codehilite"><pre><span class="p">{</span> <span class="err">`</span><span class="n">someVariable</span> <span class="p">}</span>
</pre></div>


<p>If you want to evaluate a more complex expression after the backtick, you can use parentheses:</p>
<div class="codehilite"><pre><span class="p">{</span> <span class="err">`</span><span class="p">(</span><span class="n">call</span> <span class="n">some</span> <span class="n">method</span><span class="p">(</span><span class="n">passing</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span> <span class="p">}</span>
</pre></div>


<p>Since the result of a quasiquote must be an expression, you can also use curly braces immediately after the backtick to immediately wrap the result in one:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="n">age</span> <span class="err">=</span> <span class="mi">23</span> <span class="c1">// note: not an expression</span>
<span class="k">var</span> <span class="n">expr</span> <span class="err">=</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;You are &quot;</span> <span class="err">~</span> <span class="err">`</span><span class="p">{</span> <span class="n">age</span> <span class="p">}</span> <span class="err">~</span> <span class="s">&quot; years old!&quot;</span><span class="p">)</span> <span class="p">}</span>
</pre></div>


<p class="future">
The syntax for expression literals (i.e. using curlies) may change. Metaprogramming isn't something that users are likely to do often (thankfully!), so it may make sense to free up {} for something more useful like array or map literals and use something a bit longer for expresion literals.
</p>
                <div class="nav">
<table>
  <tr>
    <td><ul><li><a href=../../index.html>Welcome</a></li>
<li><a href=../../language.html>Language</a>
<ul><li><a href=../program-structure.html>Program Structure</a></li>
<li><a href=../objects.html>Objects</a>
<ul><li><a href=booleans.html>Booleans</a></li>
<li><a href=numbers.html>Numbers</a></li>
<li><a href=strings.html>Strings</a></li>
<li><a href=nothing.html>Nothing</a></li>
<li><a href=tuples.html>Tuples</a></li>
<li><a href=records.html>Records</a></li>
<li><strong>Expression Objects</strong></li>
</ul>
</ul>
</td>
<td>
  <ul>
  <li><a href=../functions.html>Functions</a></li>
  <li><a href=../messages.html>Messages</a></li>
  <li><a href=../operators.html>Operators</a></li>
  <li><a href=../variables.html>Variables</a></li>
  <li><a href=../flow-control.html>Flow Control</a></li>
  <li><a href=../classes.html>Classes</a></li>

  </ul>
  <li><a href=../../motivation.html>Motivation</a>
  <ul><li><a href=../../motivation/design-questions.html>Design Questions</a>
  <li><a href=../../motivation/tao.html>The Tao of Magpie</a></li>

  </ul>
  <li><a href=../../hacking.html>Hacking On Magpie</a></li>
  </ul>
</td>
  </tr>
</table>
                </div><div>
        </div>
        </body>
        </html>
