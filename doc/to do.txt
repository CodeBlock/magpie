Types
- Classes
  - If we're going to keep inheritance, then we need to make sure you can't add
    a method to a sub- or super-class whose argument or return type is 
    incompatible with an overridden method elsewhere in the hierarchy. (i.e. you
    shouldn't be able to have Base foo(-> Int) and Derived foo(-> String)).
  - Need to type-check that a class's declared fields are all definitely values
    of allowed types by the end of the ctor.
  - Figure out if there's some way constructors can be extended to a) add new
    construction logic and/or b) add new fields.
  - Masquerades. Two class cannot implicitly duck type to each other even if 
    they have matching methods. However, there should be a "masquerade" function
    that will take an instance of one class and return it typed to another if
    they have compatible methods. This will allow things like mocks without
    forcing users to make everything an interface up front.
- Interfaces
  + Core imperative system to create and extend them.
  + Typing rules for them that allow other types to be assignable to them if 
    they implement all of its methods.
  - Declarative syntax that wraps that.
  - Determine if something like C#'s explicit interface implementation is
    useful. It may be nice for cases where a class implements multiple
    interfaces with overlapping names.
- Generics
  - Need to figure out how they work. One option would be that a class object
    implements ICallable and takes arguments that are types and returns a type.
    That would let you do List(Int), which is desugared to List call(Int) and
    would be implemented to return a type.
  - Need to figure out how the type parameters can be used to modify the type
    signatures of methods in an instantiated generic type. Would we just
    construct a new ClassObj for each instantiation? Or maybe when we evalate
    the type expressions, we do so in a local scope that includes the     
    instantiated type arguments bound to the names of the type parameters?
  - Figure out variance for instantiated types.
- Function types
  - These need an expression syntax that evaluates to an ICallable interface
    with type arguments for the function's argument and return types.
- Unions
  - Unlike or types, these would have named cases.
- Enums
  - Interfaces may cover this, but it might be nice to have some syntactic sugar
    for it. Java's system where enums are essentially singleton instances is
    interesting.

Expressions
- Scope guards
  - Basically destructors, or some other way to execute code at the close of a
    local scope. See also: using() in C#.
- Closures
  - In theory, they're there and work, but they need tests and probably have 
    lots of bugs.
- Floats, characters, and other atomic types
  - Pretty much the full suite of what Java provides.
- Static arguments
  - In addition to a regular argument, a method can have a static argument like
    foo[static](arg). It will be evaluated at *check* time, and bound to a name
    that's available in the context used to evaluate type expressions. This
    will let us handle type arguments for generics along with other stuff.

Syntax
- Function literals
  - The syntax for these is kind of verbose, especially for use cases like
    filter/map. A shorter lambda syntax would be nice.
- Some kind of message cascade syntax? User-defined operators can handle most
  cases (i.e. a string builder in Magpie could just have a + operator), but it
  may be nice for some things?
- Keyword arguments. Something like:
    dictionary add(key: 123 value: "hey")
  which desugars to:
    dictionary add:key:value(123, "hey")
  Also allow no keyword for the first argument:
    list insert("item" at: 3)
  which desugars to:
    list insert:at("item", 3)
- Map and/or set literals?
- Pattern-matching or switch?
- Parsewords
  Everything but the core message syntax should be moved out of Java into 
  Magpie. In Magpie, you can register a parseword, a name keyword. When the
  parser encounters that keyword, it calls a Magpie function that takes a parser
  and returns an expression. Then things like if, for, class, etc. can be
  implemented in Magpie. Users can then implement their own custom control
  structures.
- Annotations
  Users should be able to attach annotations, arbitrary expressions attached to
  other expressions. Those are executed and bound to the expression at check
  time and runtime. There should then be an API to access those annotations.
- Syntax literals and quasiquoting
  An expression like { a + b } evaluates to a data structure for the AST. Useful
  for metaprogramming and parsewords.
  

Library
- Reorganize and clean up the type stuff.
- Conversion and casting methods (is, as, explicit cast).

Other
- A well-defined package/import/namespace system including nice syntax.
- Interop with Java. Should be able to instantiate Java types and call arbitrary
  methods on those objects.
- Coroutines and/or CSP-style concurrency. Some way to easily hop between
  different callstacks, basically.
- TCO.
- Exceptions. (Or, ideally, something closer to CL's condition system.)
- Implement test infrastructure in Magpie (at least for as much as possible).