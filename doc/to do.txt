Types
- Classes
  - If we're going to keep inheritance, then we need to make sure you can't add
    a method to a sub- or super-class whose argument or return type is 
    incompatible with an overridden method elsewhere in the hierarchy. (i.e. you
    shouldn't be able to have Base foo(-> Int) and Derived foo(-> String)).
  - Need to type-check that a class's declared fields are all definitely values
    of allowed types by the end of the ctor.
  - Figure out if there's some way constructors can be extended to a) add new
    construction logic and/or b) add new fields.
- Interfaces
  - Core imperative system to create and extend them.
  - Declarative syntax that wraps that.
  - Typing rules for them that allow other types to be assignable to them if 
    they implement all of its methods.
- Generics
  - Need to figure out how they work. One option would be that a class object
    implements ICallable and takes arguments that are types and returns a type.
    That would let you do List(Int), which is desugared to List call(Int) and
    would be implemented to return a type.
  - Need to figure out how the type parameters can be used to modify the type
    signatures of methods in an instantiated generic type. Would we just
    construct a new ClassObj for each instantiation? Or maybe when we evalate
    the type expressions, we do so in a local scope that includes the     
    instantiated type arguments bound to the names of the type parameters?
  - Figure out variance for instantiated types.
- Function types
  - These need an expression syntax that evaluates to an ICallable interface
    with type arguments for the function's argument and return types.
- Unions
  - Unlike or types, these would have named cases.

Expressions
- Scope guards
  - Basically destructors, or some other way to execute code at the close of a
    local scope.
- Closures
  - In theory, they're there and work, but they need tests and probably have 
    lots of bugs.

Syntax
- Being able to omit parens with single-arg methods is nice, but it feels weird
  with thing like "print" where the arg may be an expression with lower
  precedence so you have to parentheses for that:
  
  print "hi"
  print ("a" + "b") // parens here are annoying
  
  It would be nice if it felt consistent.

- Some kind of message cascade syntax. Users shouldn't have to explicitly create
  fluid interfaces.

  builder.append "one" ..append "two" ..append "three"

- Consider following more IO-style syntax:

  foo bar                // no-arg method
  foo bar(1)             // one-arg method 
  foo bar bang(2, 3) baz // chain

  So dots aren't needed for methods, but parens always are for args.