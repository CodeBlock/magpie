Magpie syntax file (.mags)

Defines new parser rules. Unlike macros, which can be parsed using the
normal parser, but are evaluated at compile time, parser rules are
evaluated at *parse* time.

The basic idea is that (aside from core things like function calls and
operators) different Magpie syntactical constructs all start with a
different keyword: "if", "let", "for", "struct", etc. This means that
at the top level, parsing is a big switch based on the initial
keyword. A parse rule defines a new one and then provides the parser
behavior after that keyword has been parsed.

A parser rule is a function. Its name is the starting keyword that
selects the rule. It takes in a Parser object, and returns an
Expression, which is an AST composed of the core desugared syntax that
is built into Magpie.

Here's how "let" can be defined in terms of the built-in "if":

    let (parser Parser -> Expression)
        def name <- parser.ReadName
        parser.ReadLeftArrow
    
        // read the condition
        def conditionExpr <- ParseBlock (parser, "then")
        parser.ConsumeOptionalLine
        ConsumeName (parser, "then")
    
        // read the body
        def body <- ParseBlock parser
    
        def option <- parser.TempName
    
        def defineOption <- DefineExpr (option, condition, false)
        def condition    <- CallExpr (NameExpr "Some?", option)
        def getValue     <- CallExpr (NameExpr "SomeValue", option)
        def defineValue  <- DefineExpr (name, getValue, false)
    
        def bodyExpr     <- BlockExpr [defineValue, body]
        def ifThen       <- IfExpr (condition, bodyExpr, UnitExpr)
    
        BlockExpr [defineOption, ifThen]
    end

Using AST literals, this becomes:

    let (parser Parser -> Expression)
        def name <- parser.ReadName
        parser.ReadLeftArrow

        // read the condition
        def condition <- ParseBlock (parser, "then")
        parser.ConsumeOptionalLine
        ConsumeName (parser, "then")

        // read the body
        def body <- ParseBlock parser

        // define a temporary variable for the option
        def temp <- parser.TempName

        {
            def `temp <- `condition
            if Some? `temp then
                def `name <- SomeValue `temp
                `body
            end
        }
    end