extend class Function
    // Add a shared to Function so that it's easily visible from the interpreter
    // (which already has a reference to Function) so that it can create
    // FunctionType objects.
    shared def newType(paramType Type, returnType Type, static? Bool -> Type)
        FunctionType new(paramType, returnType, static?)
    end
end

class FunctionType
    this(paramType Type, returnType Type, static? Bool)
        this paramType = paramType
        this returnType = returnType
        this static? = static?
    end

    get string String =
        var result = paramType string + " -> " + returnType
        if static? then result = "[" + result + "]"
        result
    end

    // TODO(bob): Once interfaces are in, function types can just become sugar for
    // creating ICallable(Arg, Return) instances.
    def canAssignFrom(other Type -> Bool)
        // Both must be functions.
        let otherFn = as[FunctionType](other) then
            // Parameter must be contravariant and return must be covariant.
            if static? != otherFn static? then return false
            if otherFn paramType canAssignFrom(paramType) not then return false
            if returnType canAssignFrom(otherFn returnType) not then return false
            
            true
        else false
    end

    def getMemberType(name String -> Type | Nothing)
        // Just defer to the base function class.
        Function getMemberType(name)
    end

    def getSetterType(name String -> Type | Nothing)
        // Just defer to the base function class.
        Function getSetterType(name)
    end

    def ==(other -> Bool)
        let fnType = as[FunctionType](other) then
            static? == fnType static? and
                paramType == fnType paramType and
                returnType == fnType returnType
        else false
    end

    def !=(other -> Bool) (this == other) not

    var paramType  Type
    var returnType Type
    var static?    Bool
end
