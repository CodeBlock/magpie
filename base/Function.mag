extend class Function
    // Make "Function" a functor that you can call to instantiate function types.
    // Type annotations of function types look like Function(Int, String) 
    shared def call(paramType Type, returnType Type -> Type)
        FunctionType new(paramType, returnType)
    end
end

class FunctionType
    this(paramType Type, returnType Type)
        this paramType = paramType
        this returnType = returnType
    end

    get string String = paramType string + " -> " + returnType

    // TODO(bob): Once interfaces are in, function types can just become sugar for
    // creating ICallable(Arg, Return) instances.
    def canAssignFrom(other Type -> Bool)
        // Both must be functions.
        let otherFn = as[FunctionType](other) then
            // Parameter must be contravariant and return must be covariant.
            otherFn paramType canAssignFrom(paramType) and
                returnType canAssignFrom(otherFn returnType)
        else false
    end

    def getMemberType(name String -> Type | Nothing)
        // Just defer to the base function class.
        Function getMemberType(name)
    end

    def getSetterType(name String -> Type | Nothing)
        // Just defer to the base function class.
        Function getSetterType(name)
    end

    def ==(other -> Bool)
        let fnType = as[FunctionType](other) then
            paramType == fnType paramType and returnType == fnType returnType
        else false
    end

    def !=(other -> Bool) (this == other) not

    var paramType Type
    var returnType Type
end

class StaticFunctionType
    this(params, body)
        this params = params
        this body = body
    end
    
    var params Dynamic
    var body Dynamic
end