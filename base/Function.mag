extend class Function
    // Make "Function" a functor that you can call to instantiate function types.
    // Type annotations of function types look like Function(Int, String) 
    shared call(paramType Type, returnType Type -> Type)
        FunctionType new(paramType, returnType)
    end
end

class FunctionType
    this(paramType Type, returnType Type)
        this paramType = paramType
        this returnType = returnType
    end

    // TODO(bob): Once interfaces are in, function types can just become sugar for
    // creating ICallable(Arg, Return) instances.
    canAssignFrom(other Type -> Bool)
        // Both must be functions.
        let otherFn = as[FunctionType](other) then
            // Parameter must be contravariant and return must be covariant.
            otherFn paramType canAssignFrom(paramType) and
                returnType canAssignFrom(otherFn returnType)
        else false
    end

    getMemberType(name String -> Type | Nothing)
        // Just defer to the base function class.
        Function getMemberType(name)
    end

    getSetterType(name String -> Type | Nothing)
        // Just defer to the base function class.
        Function getSetterType(name)
    end

    |(other Type -> Type)
        OrType combine(this, other)
    end

    ==(other -> Bool)
        let fnType = as[FunctionType](other) then
            paramType == fnType paramType and returnType == fnType returnType
        else false
    end

    !=(other -> Bool) (this == other) not

    paramType Type
    returnType Type
end

FunctionType defineGetter("string", fn(-> String)
    paramType string + " -> " + returnType string
end)

class StaticFunctionType
    this(params, body)
        this params = params
        this body = body
    end
    
    params Dynamic
    body Dynamic
end