class Token
    get string String = tokenType ~~ value
    
    shared get leftParen     Token = Token new(TokenType leftParen)
    shared get rightParen    Token = Token new(TokenType rightParen)
    shared get leftBracket   Token = Token new(TokenType leftBracket)
    shared get rightBracket  Token = Token new(TokenType rightBracket)
    shared get leftBrace     Token = Token new(TokenType leftBrace)
    shared get rightBrace    Token = Token new(TokenType rightBrace)
    shared get comma         Token = Token new(TokenType comma)
    shared get dot           Token = Token new(TokenType dot)
    shared get equals        Token = Token new(TokenType equals)
    shared get line          Token = Token new(TokenType line)
    
    shared def name(name String -> Token) Token new(TokenType name, name)
    shared def field(name String -> Token) Token new(TokenType field, name)
    shared def operator(name String -> Token) Token new(TokenType operator, name)
    shared def boolLiteral(value Bool -> Token) Token new(TokenType boolLiteral, value)
    shared def intLiteral(value Int -> Token) Token new(TokenType intLiteral, value)
    shared def stringLiteral(value String -> Token) Token new(TokenType stringLiteral, value)

    var tokenType TokenType
    var value     Bool | Int | Nothing | String
end

class TokenType
    shared def equal?(left TokenType, right TokenType)
        left value == right value
    end
    
    shared def new(value Int, name String) construct(value: value, name: name)
    
    shared get leftParen     TokenType = TokenType new(0, "leftParen")
    shared get rightParen    TokenType = TokenType new(1, "rightParen")
    shared get leftBracket   TokenType = TokenType new(2, "leftBracket")
    shared get rightBracket  TokenType = TokenType new(3, "rightBracket")
    shared get leftBrace     TokenType = TokenType new(4, "leftBrace")
    shared get rightBrace    TokenType = TokenType new(5, "rightBrace")
    shared get comma         TokenType = TokenType new(6, "comma")
    shared get dot           TokenType = TokenType new(7, "dot")
    shared get equals        TokenType = TokenType new(8, "equals")
    shared get line          TokenType = TokenType new(9, "line")
    shared get name          TokenType = TokenType new(10, "name")
    shared get field         TokenType = TokenType new(11, "field")
    shared get operator      TokenType = TokenType new(12, "operator")
    shared get boolLiteral   TokenType = TokenType new(13, "boolLiteral")
    shared get intLiteral    TokenType = TokenType new(14, "intLiteral")
    shared get stringLiteral TokenType = TokenType new(15, "stringLiteral")

    get string String = name
    
    var value Int
    var name  String
end

// Unfortunately, we can't be this clever here. Token needs to be evaluated
// before any of the parsers can be evaluated. That means it can't use anything
// fancy like... uh... "to" because that would require importing "Int.mag"
// before this, but then Int.mag in turn couldn't use any parse words.
/*
// Turn TokenType in an enum-like class by defining a bunch of shared getters on
// it that return instances of TokenType. This way, you can do "TokenType dot"
// and get back the dot TokenType.
do
    // Note: The order that these appear must be kept-in sync with the values
    // used in MagpieParserBuiltIns.java.
    var types = ("leftParen rightParen leftBracket rightBracket leftBrace " ~
                "rightBrace comma dot equals name field operator boolLiteral " ~
                "intLiteral stringLiteral") split(" ")
    for type = types
    for i = 0 to(types count) do
        // Define a TokenType "enum" for the type.
        var tokenType = TokenType new(name: type, value: i)
        Reflect getClass(TokenType) defineGetter(type,
                fn(-> TokenType) tokenType)
        
        // Also make a Token constructor for it.
        var tokenMetaclass = Reflect getClass(Token)
        if type == "boolLiteral" then
            // Define a Token constructor that takes a Bool value.
            tokenMetaclass defineMethod(type, fn(value Bool -> Token)
                Token new(tokenType: tokenType, value: value)
            end)
        else if type == "intLiteral" then
            // Define a Token constructor that takes an Int value.
            tokenMetaclass defineMethod(type, fn(value Int -> Token)
                Token new(tokenType: tokenType, value: value)
            end)
        else if "name field operator stringLiteral" contains?(type) then
            // Define a Token constructor that takes a String value.
            tokenMetaclass defineMethod(type, fn(value String -> Token)
                Token new(tokenType: tokenType, value: value)
            end)
        else
            // Token doesn't have a value, so just define a getter to return a
            // singleton instance of it.
            var token = Token new(tokenType: tokenType)
            tokenMetaclass defineGetter(type, fn(-> Token) token)
        end
    end
end
*/