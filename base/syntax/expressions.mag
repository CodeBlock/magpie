// Note: This file is parsed before any of the parsewords have been defined, so
// it only uses core syntax.

class AndExpression
    shared def new(left Expression, right Expression -> OrExpression)
        construct(left: left, right: right)
    end
        
    get string String =
        left string ~ " and " ~ right string
    end
end

AndExpression declareField("left", false, fn Expression)
AndExpression declareField("right", false, fn Expression)

class ApplyExpression
    shared def new(target Expression, argument Expression -> ApplyExpression)
        construct(target: target, argument: argument)
    end
    
    get string String =
        target string ~ "(" ~ argument string ~ ")"
    end
end

ApplyExpression declareField("target", false, fn Expression)
ApplyExpression declareField("argument", false, fn Expression)

class AssignExpression
    shared def new(receiver Expression | Nothing,
                   name String,
                   value Expression -> AssignExpression)
        construct(receiver: receiver, name: name, value: value)
    end
        
    get string String =
        let receiver then
            receiver string ~~ name ~ " = " ~ value string
        else
            name ~ " = " ~ value string
        end
    end
end

AssignExpression declareField("receiver", false, fn Expression | Nothing)
AssignExpression declareField("name", false, fn String)
AssignExpression declareField("value", false, fn Expression)

class BoolExpression
    shared def new(value Bool -> BoolExpression) construct(value: value)
    
    get string String = value string
end

BoolExpression declareField("value", false, fn Bool)

// TODO(bob): Support catch expression.
class BlockExpression
    shared def new(expressions List(Expression) -> BlockExpression)
        construct(expressions: expressions)
    end
    
    get string String = String join(expressions, "\n")
end

BlockExpression declareField("expressions", false, fn List(Expression))

class BreakExpression
    get string String = "break"
end

class ExpressionExpression
    shared def new(body Expression -> ExpressionExpression)
        construct(body: body)
    end
        
    get string String =
        "{ " ~ body string ~ " }"
    end
end

ExpressionExpression declareField("body", false, fn Expression)

class FunctionExpression
    shared def new(type FunctionTypeExpression, body Expression ->
                   FunctionExpression)
        construct(functionType: type, body: body)
    end
        
    get string String = "fn " ~ functionType ~~ body
end

FunctionExpression declareField("functionType", false, fn FunctionTypeExpression)
FunctionExpression declareField("body", false, fn Expression)

class IfExpression
    shared def new(name String | Nothing,
                   condition Expression,
                   thenArm Expression,
                   elseArm Expression -> IfExpression)
        construct(name: name, condition: condition,
                  thenArm: thenArm, elseArm: elseArm)
    end
    
    get let? Bool = name != nothing
    
    get string String =
        if let? then
            "let " ~ name ~ " "
        else
            "if "
        end ~ condition ~ " then " ~ thenArm ~ " else " ~ elseArm
    end
end

IfExpression declareField("name", false, fn String | Nothing)
IfExpression declareField("condition", false, fn Expression)
IfExpression declareField("thenArm", false, fn Expression)
IfExpression declareField("elseArm", false, fn Expression)

class IntExpression
    shared def new(value Int -> IntExpression) construct(value: value)
    
    get string String = value string
end

IntExpression declareField("value", false, fn Int)

class LoopExpression
    shared def new(conditions List(Expression), body Expression ->
                   LoopExpression)
        construct(conditions: conditions, body: body)
    end
    
    get string String =
        "not implemented!"
        /*
        var result = ""
        for i = 0 until(conditions count)
        for condition = conditions do
            result = result ~ "while " ~ condition
      
            if i < (conditions count - 1) then
                result = result ~ "\n"
            else
                result = result ~ " do\n"
            end
        end
        result ~ body
        */
    end
end

LoopExpression declareField("conditions", false, fn List(Expression))
LoopExpression declareField("body", false, fn Expression)

class MessageExpression
    shared def new(receiver Expression | Nothing,
                   name String -> MessageExpression)
        construct(receiver: receiver, name: name)
    end
        
    get string String =
        let receiver then receiver string ~~ name else name
    end
end

MessageExpression declareField("receiver", false, fn Expression | Nothing)
MessageExpression declareField("name", false, fn String)

class NothingExpression
    get string String = "nothing"
end

class OrExpression
    shared def new(left Expression, right Expression -> OrExpression)
        construct(left: left, right: right)
    end
        
    get string String =
        left string ~ " or " ~ right string
    end
end

OrExpression declareField("left", false, fn Expression)
OrExpression declareField("right", false, fn Expression)

class RecordExpression
    shared def new(fields List(String, Expression) -> RecordExpression)
        construct(fields: fields)
    end
    
    get string String = "record"
end

RecordExpression declareField("fields", false, fn List(String, Expression))

class ReturnExpression
    shared def new(value Expression -> ReturnExpression)
        construct(value: value)
    end
        
    get string String = "return " ~ value
end

ReturnExpression declareField("value", false, fn Expression)

class ScopeExpression
    shared def new(body Expression -> ScopeExpression)
        construct(body: body)
    end
        
    get string String = "do " ~ body
end

ScopeExpression declareField("body", false, fn Expression)

class StringExpression
    shared def new(value String -> StringExpression) construct(value: value)
    
    get string String = "\"" ~ value ~ "\""
end

StringExpression declareField("value", false, fn String)

class ThisExpression
    get string String = "this"
end

class TupleExpression
    shared def new(fields List(Expression) -> TupleExpression)
        construct(fields: fields)
    end
    
    get string String = String join(fields)
end

TupleExpression declareField("fields", false, fn List(Expression))

class TypeofExpression
    shared def new(body Expression -> TypeofExpression)
        construct(body: body)
    end
        
    get string String = "typeof " ~ body
end

TypeofExpression declareField("body", false, fn Expression)

class UnsafeCastExpression
    shared def new(type Expression, value Expression -> UnsafeCastExpression)
        construct(type: type, value: value)
    end
        
    get string String = "unsafecast[" ~ type ~ "](" ~ value ~ ")"
end

UnsafeCastExpression declareField("type", false, fn Expression)
UnsafeCastExpression declareField("value", false, fn Expression)

class VariableExpression
    shared def new(name String, value Expression -> VariableExpression)
        construct(name: name, value: value)
    end
    
    get string String =
        "var " ~ name ~ " = " ~ value string
    end
end

VariableExpression declareField("name", false, fn String)
VariableExpression declareField("value", false, fn Expression)
