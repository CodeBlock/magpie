// Note: This file is parsed before any of the parsewords have been defined, so
// it only uses core syntax.

class AndExpression
    shared def new(left Expression, right Expression -> OrExpression)
        construct(left: left, right: right)
    end

    get string String =
        left string ~ " and " ~ right string
    end
end

AndExpression declareField("left", false, fn Expression)
AndExpression declareField("right", false, fn Expression)

class ApplyExpression
    shared def new(target Expression, typeArgs List(Expression),
            argument Expression -> ApplyExpression)
        construct(target: target, typeArgs: typeArgs, argument: argument)
    end

    get string String =
        target string ~ "(" ~ argument string ~ ")"
    end
end

ApplyExpression declareField("target", false, fn Expression)
ApplyExpression declareField("typeArgs", false, fn List(Expression))
ApplyExpression declareField("argument", false, fn Expression)

class AssignExpression
    shared def new(receiver Expression | Nothing,
                   name String,
                   value Expression -> AssignExpression)
        construct(receiver: receiver, name: name, value: value)
    end

    get string String =
        let receiver then
            receiver string ~~ name ~ " = " ~ value string
        else
            name ~ " = " ~ value string
        end
    end
end

AssignExpression declareField("receiver", false, fn Expression | Nothing)
AssignExpression declareField("name", false, fn String)
AssignExpression declareField("value", false, fn Expression)

class BoolExpression
    shared def new(value Bool -> BoolExpression) construct(value: value)

    get string String = value string
end

BoolExpression declareField("value", false, fn Bool)

class BlockExpression
    shared def new(expressions List(Expression), catchExpression Expression ->
            BlockExpression)
        construct(expressions: expressions, catchExpression: catchExpression)
    end

    get string String = String join(expressions, "\n")
end

BlockExpression declareField("expressions", false, fn List(Expression))
BlockExpression declareField("catchExpression", false, fn Expression | Nothing)

class BreakExpression
    get string String = "break"
end

class FunctionExpression
    shared def new(type FunctionTypeExpression, body Expression ->
                   FunctionExpression)
        construct(functionType: type, body: body)
    end

    get string String = "fn " ~ functionType ~~ body
end

FunctionExpression declareField("functionType", false, fn FunctionTypeExpression)
FunctionExpression declareField("body", false, fn Expression)

class IfExpression
    shared def new(name String | Nothing,
                   condition Expression,
                   thenArm Expression,
                   elseArm Expression -> IfExpression)
        construct(name: name, condition: condition,
            thenArm: thenArm, elseArm: elseArm)
    end

    get let? Bool = name != nothing

    get string String =
        %if%(let?, "let " ~ name ~ " ", "if ") ~
            condition ~ " then " ~ thenArm ~ " else " ~ elseArm
    end
end

IfExpression declareField("name", false, fn String | Nothing)
IfExpression declareField("condition", false, fn Expression)
IfExpression declareField("thenArm", false, fn Expression)
IfExpression declareField("elseArm", false, fn Expression)

class IntExpression
    shared def new(value Int -> IntExpression) construct(value: value)

    get string String = value string
end

IntExpression declareField("value", false, fn Int)

class LoopExpression
    shared def new(body Expression -> LoopExpression)
        construct(body: body)
    end

    get string String =
        "not implemented!"
    end
end

LoopExpression declareField("body", false, fn Expression)

class MatchCase
    shared def new(pattern Pattern, body Expression -> MatchCase)
        construct(pattern: pattern, body: body)
    end
end

MatchCase declareField("pattern", false, fn Pattern)
MatchCase declareField("body", false, fn Expression)

class MatchExpression
    shared def new(value Expression, cases List(MatchCase) -> MatchExpression)
        construct(value: value, cases: cases)
    end

    get string String =
        "not implemented!"
    end
end

MatchExpression declareField("value", false, fn Expression)
MatchExpression declareField("cases", false, fn List(MatchCase))

class MessageExpression
    shared def new(receiver Expression | Nothing,
                   name String -> MessageExpression)
        construct(receiver: receiver, name: name)
    end

    get string String =
        %if%(Reflect same?(receiver, nothing) not,
            %unsafecast%(Expression, receiver) string ~~ name, name)
    end
end

MessageExpression declareField("receiver", false, fn Expression | Nothing)
MessageExpression declareField("name", false, fn String)

class NothingExpression
    get string String = "nothing"
end

class OrExpression
    shared def new(left Expression, right Expression -> OrExpression)
        construct(left: left, right: right)
    end

    get string String =
        left string ~ " or " ~ right string
    end
end

OrExpression declareField("left", false, fn Expression)
OrExpression declareField("right", false, fn Expression)

class QuotationExpression
    shared def new(body Expression -> QuotationExpression)
        construct(body: body)
    end

    get string String =
        "{ " ~ body string ~ " }"
    end
end

QuotationExpression declareField("body", false, fn Expression)

class RecordExpression
    shared def new(fields List(String, Expression) -> RecordExpression)
        construct(fields: fields)
    end

    get string String = "record"
end

RecordExpression declareField("fields", false, fn List(String, Expression))

class ReturnExpression
    shared def new(value Expression -> ReturnExpression)
        construct(value: value)
    end

    get string String = "return " ~ value
end

ReturnExpression declareField("value", false, fn Expression)

class ScopeExpression
    shared def new(body Expression -> ScopeExpression)
        construct(body: body)
    end

    get string String = "do " ~ body
end

ScopeExpression declareField("body", false, fn Expression)

class StringExpression
    shared def new(value String -> StringExpression) construct(value: value)

    get string String = "\"" ~ value ~ "\""
end

StringExpression declareField("value", false, fn String)

class ThisExpression
    get string String = "this"
end

class TupleExpression
    shared def new(fields List(Expression) -> TupleExpression)
        construct(fields: fields)
    end

    get string String = String join(fields)
end

TupleExpression declareField("fields", false, fn List(Expression))

class TypeofExpression
    shared def new(body Expression -> TypeofExpression)
        construct(body: body)
    end

    get string String = "typeof " ~ body
end

TypeofExpression declareField("body", false, fn Expression)

class UnsafeCastExpression
    shared def new(type Expression, value Expression -> UnsafeCastExpression)
        construct(type: type, value: value)
    end

    get string String = "unsafecast[" ~ type ~ "](" ~ value ~ ")"
end

UnsafeCastExpression declareField("type", false, fn Expression)
UnsafeCastExpression declareField("value", false, fn Expression)

class VariableExpression
    shared def new(pattern Pattern, value Expression -> VariableExpression)
        construct(pattern: pattern, value: value)
    end

    get string String =
        "var " ~ pattern ~ " = " ~ value string
    end
end

VariableExpression declareField("pattern", false, fn Pattern)
VariableExpression declareField("value", false, fn Expression)
