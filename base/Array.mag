extend class Array
    shared new(-> ArrayType new(Object)) Array of()
    
    // TODO(bob): This is kind of hokey.
    shared newType(elementType Type -> ArrayType)
        ArrayType new(elementType)
    end

    shared canAssignFrom(other Type -> Bool)
        if this == other then
            true
        else if other type == ArrayType then
            true
        else false
    end
    
    iterate(-> ArrayIterator) ArrayIterator new(this)

    copy(-> Array)
        var result = Array new()
        for item = this do result add(item)
        result
    end

    sortByString(-> Array)
        var result = copy()
    
        // TODO(bob): Awful bubble sort FTW!
        for i = 0 until(result count) do
            for j = (i + 1) until(result count) do
                if result(i) string > result(j) string then
                    var temp = result(i)
                    result(i) = result(j)
                    result(j) = temp
                end
            end
        end
    
        result
    end

    unique(-> ArrayType new(Object))
        var result = Array new()
        for item = this do
            if result count == 0 then
                result add(item)
            else if result(-1) != item then result add(item)
        end
    
        result
    end

    // TODO(bob): rename contains?
    contains(item -> Bool)
        for element = this do
            if item == element then return true
        end
        false
    end

    // TODO(bob): Need generics to use for return type.
    first(predicate -> Dynamic)
        for element = this do
            if predicate(element) then return element
        end
        nothing
    end

    swap(a Int, b Int ->)
        // TODO(bob): Bounds check
        var temp = this(a)
        this(a) = this(b)
        this(b) = temp
    end
end

Array defineGetter("string", fn(-> String)
    var text = "["
    for i = 0 until(count) do
        text = text + this(i) string
        if i < (count - 1) then text = text + ", "
    end
    text + "]"
end)

// TODO(bob): Need generics to use for return type.
Array defineGetter("last", fn(-> Dynamic)
    this(count - 1)
end)

Array defineGetter("type", fn(-> Type)
    // TODO(bob): Hack!
    var elementType = this(0) type
    ArrayType new(elementType)
end)

class ArrayType
    this(elementType Type)
        this elementType = elementType
    end
    
    canAssignFrom(other Type -> Bool)
        let otherArray = as[ArrayType](other) then
            // Element type must match exactly (not variant).
            elementType == otherArray elementType
        else false
    end

    getMemberType(name String -> Type | Nothing)
        // TODO(bob): Hackish. Strongly-type the array members based on the
        // element type.
        if name == "assign" then
            Function(elementType, elementType)
        else if name == "copy" then
            Function(Nothing, this)
        else if name == "contains" then
            Function(elementType, Bool)
        else if name == "call" then
            Function(Int, elementType)
        else if name == "first" then
            Function(Function(elementType, Bool), elementType | Nothing)
        else if name == "iterate" then
            Function(Nothing, ArrayIteratorType new(elementType))
        else Array getMemberType(name)
    end
    
    getSetterType(name String -> Type | Nothing)
        nothing
    end

    ==(other -> Bool)
        let otherArray = as[ArrayType](other) then
            // Element type must match exactly (not variant).
            elementType == otherArray elementType
        else false
    end
    
    !=(other -> Bool) (this == other) not
    
    |(other Type -> Type)
        OrType combine(this, other)
    end

    elementType Type
end

ArrayType defineGetter("string", fn(-> String)
    "array of " + elementType
end)

class ArrayIterator
    this(array Array ->)
        this array = array
        this index = -1
    end
    
    next(-> Bool)
        index = index + 1
        index < array count
    end

    array Array
    index Int
end

// TODO(bob): Need generics for return type.
ArrayIterator defineGetter("current", fn array(index))

ArrayIterator defineGetter("type", fn(-> Type)
    // TODO(bob): Hack!
    var elementType = array(0) type
    ArrayIteratorType new(elementType)
end)

class ArrayIteratorType
    this(elementType)
        this elementType = elementType
    end
    
    canAssignFrom(other Type -> Bool)
        let otherArray = as[ArrayIteratorType](other) then
            // Array iterators are covariant with their element type.
            elementType canAssignFrom(otherArray elementType)
        else false
    end
    
    getMemberType(name String -> Type | Nothing)
        // Strongly-type the iterator.
        if name == "current" then return elementType
        // Use the generic type of the other methods.
        ArrayIterator getMemberType(name)
    end
    
    getSetterType(name String -> Type | Nothing)
        nothing
    end
    
    ==(other -> Bool)
        let otherArray = as[ArrayIteratorType](other) then
            elementType == otherArray elementType
        else false
    end
    
    !=(other -> Bool) (this == other) not
    
    |(other Type -> Type)
        OrType combine(this, other)
    end
    
    elementType Type
end

ArrayIteratorType defineGetter("string", fn(-> String)
    "array of " + elementType + " iterator"
end)
