extend class Array
    shared def new(-> ArrayType new(Object)) Array of()
    
    // TODO(bob): This is kind of hokey.
    shared def newType(elementType Type -> ArrayType)
        ArrayType new(elementType)
    end

    shared def canAssignFrom(other Type -> Bool)
        if this == other then
            true
        else if other type == ArrayType then
            true
        else false
    end
    
    get string String =
        var text = "["
        for i = 0 until(count) do
            text = text + this(i) string
            if i < (count - 1) then text = text + ", "
        end
        text + "]"
    end

    // TODO(bob): Need generics to use for return type.
    get last = this(count - 1)

    get type Type =
        // TODO(bob): Hack!
        var elementType = this(0) type
        ArrayType new(elementType)
    end

    def iterate(-> ArrayIterator) ArrayIterator new(this)

    def copy(-> Array)
        var result = Array new()
        for item = this do result add(item)
        result
    end

    def sortByString(-> Array)
        var result = copy()
    
        // TODO(bob): Awful bubble sort FTW!
        for i = 0 until(result count) do
            for j = (i + 1) until(result count) do
                if result(i) string > result(j) string then
                    var temp = result(i)
                    result(i) = result(j)
                    result(j) = temp
                end
            end
        end
    
        result
    end

    def unique(-> ArrayType new(Object))
        var result = Array new()
        for item = this do
            if result count == 0 then
                result add(item)
            else if result(-1) != item then result add(item)
        end
    
        result
    end

    // TODO(bob): rename contains?
    def contains(item -> Bool)
        for element = this do
            if item == element then return true
        end
        false
    end

    // TODO(bob): Need generics to use for return type.
    def first(predicate -> Dynamic)
        for element = this do
            if predicate(element) then return element
        end
        nothing
    end

    def swap(a Int, b Int ->)
        // TODO(bob): Bounds check
        var temp = this(a)
        this(a) = this(b)
        this(b) = temp
    end
end

class ArrayType
    this(elementType Type)
        this elementType = elementType
    end
    
    get string String = "array of " + elementType

    def canAssignFrom(other Type -> Bool)
        let otherArray = as[ArrayType](other) then
            // Element type must match exactly (not variant).
            elementType == otherArray elementType
        else false
    end

    def getMemberType(name String -> Type | Nothing)
        // TODO(bob): Hackish. Strongly-type the array members based on the
        // element type.
        match name
        case "assign"   then elementType => elementType
        case "copy"     then Nothing => this
        case "contains" then elementType => Bool
        case "call"     then Int => elementType
        case "first"    then (elementType => Bool) => (elementType | Nothing)
        case "iterate"  then Nothing => ArrayIteratorType new(elementType)
        else                 Array getMemberType(name)
        end
    end
    
    def getSetterType(name String -> Type | Nothing)
        nothing
    end

    def ==(other -> Bool)
        let otherArray = as[ArrayType](other) then
            // Element type must match exactly (not variant).
            elementType == otherArray elementType
        else false
    end
    
    def !=(other -> Bool) (this == other) not
    
    var elementType Type
end

class ArrayIterator
    this(array Array)
        this array = array
        this index = -1
    end
    
    // TODO(bob): Need generics for return type.
    get current Dynamic = array(index)

    get type Type =
        // TODO(bob): Hack!
        var elementType = array(0) type
        ArrayIteratorType new(elementType)
    end

    def next(-> Bool)
        index = index + 1
        index < array count
    end

    var array Array
    var index Int
end

class ArrayIteratorType
    this(elementType)
        this elementType = elementType
    end
    
    get string String = "array of " + elementType + " iterator"

    def canAssignFrom(other Type -> Bool)
        let otherArray = as[ArrayIteratorType](other) then
            // Array iterators are covariant with their element type.
            elementType canAssignFrom(otherArray elementType)
        else false
    end
    
    def getMemberType(name String -> Type | Nothing)
        // Strongly-type the iterator.
        if name == "current" then return elementType
        // Use the generic type of the other methods.
        ArrayIterator getMemberType(name)
    end
    
    def getSetterType(name String -> Type | Nothing)
        nothing
    end
    
    def ==(other -> Bool)
        let otherArray = as[ArrayIteratorType](other) then
            elementType == otherArray elementType
        else false
    end
    
    def !=(other -> Bool) (this == other) not
    
    var elementType Type
end
