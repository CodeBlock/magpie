class RangeIterator
    this(start Int, stop Int)
        // rollback so the first call to next advances to the first
        current = start - 1
        this stop = stop
    end
    
    current Int
    stop    Int
end

def RangeIterator next(-> Bool)
    current = current + 1
    current <= stop
end

class Range
    this(start Int, stop Int)
        this start = start
        this stop = stop
    end
    
    start Int
    stop  Int
end
    
def Range iterate(-> RangeIterator)
    RangeIterator new(start, stop)
end

// Extend the built-in classes.
def Object !=(other -> Bool) (this == other) not

// Add generator methods on Ints.
def Int times (-> Range) Range new(0, this - 1)
def Int to (last Int -> Range) Range new(this, last)
def Int until (last Int -> Range) Range new(this, last - 1)

def String apply (index Int -> String) this at(index)

def Object toString(-> String) "object"
def String toString(-> String) this
def Nothing toString(-> String) "nothing"
def Class toString(-> String) name

// Provide a generic print that converts arg to string first.
def Object print(arg) printRaw(arg toString)

// Truthiness.
def Object true?(-> Bool) true
def Bool true?(-> Bool) this
def Int true?(-> Bool) this != 0
def String true?(-> Bool) this count > 0
def Nothing true?(-> Bool) false

def String ==(other -> String) this compareTo(other) == 0
def String !=(other -> String) this compareTo(other) != 0
def String <(other -> String) this compareTo(other) < 0
def String >(other -> String) this compareTo(other) > 0
def String <=(other -> String) this compareTo(other) <= 0
def String >=(other -> String) this compareTo(other) >= 0

// Type relations.

shared Nothing canAssignFrom(other IType -> Bool) other == Nothing

def Class canAssignFrom(other IType -> Bool)
    // Not even object can assign from Nothing.
    if other == Nothing then return false
    
    if other type == OrType then return false
    
    // A derived type can be assigned to a base type, so walk up the chain
    // looking for this type.
    while other != Object do
        if this == other then return true
        // Bail if got stuck in an infinite loop.
        if other == nothing then return false
        other = other parent
    end
    
    // If we got here, the only thing other has in common is Object, so see if
    // that's us.
    this == Object
end

class ArrayIterator
    this(array Array ->)
        this array = array
        this index = -1
    end
    
    array Array
    index Int
end

def ArrayIterator next(-> Bool)
    index = index + 1
    index < array count
end

def ArrayIterator current() array[index]

def Array iterate(-> ArrayIterator) ArrayIterator new(this)

def Array toString(-> String)
    var text = "["
    for i = 0 until(count) do
        text = text + this[i] toString
        if i < (count - 1) then text = text + ", "
    end
    text + "]"
end

def Array copy(-> Array)
    var result = []
    for item = this do result add(item)
    result
end

def Array sortByString(-> Array)
    var result = copy
    
    // TODO(bob): Awful bubble sort FTW!
    for i = 0 until(result count) do
        for j = (i + 1) until(result count) do
            if result[i] toString > result[j] toString then
                var temp = result[i]
                result[i] = result[j]
                result[j] = temp
            end
        end
    end
    
    result
end

def Array unique(-> Array)
    var result = []
    for item = this do
        if result count == 0 then result add(item)
        else
            if result[-1] != item then result add(item)
        end
    end
    
    result
end

def Array contains(item -> Bool)
    for element = this do
        if item == element then return true
    end
    false
end

def Class |(other IType -> OrType)
    // combine the cases of both arms
    var cases = [this]
    
    if other type == OrType then
        for item = other cases do cases add(item)
    else
        cases add(other)
    end
    
    // sort and remove the duplicates
    cases = cases sortByString unique
    
    OrType new(cases)
end

class OrType
    this(cases)
        this cases = cases
    end
    
    cases Array // TODO(bob): Array of(IType)
end

def OrType toString(-> String)
    var result = ""
    for index = 0 until(cases count) do
        result = result + cases[index] toString
        if index < (cases count - 1) then result = result + " | "
    end
    result
end

def OrType |(other IType -> OrType)
    // combine the cases of both arms
    var union = cases copy

    if other type == OrType then
        for item = other cases do union add(item)
    else
        union add(other)
    end

    // sort and remove the duplicates
    union = union sortByString unique

    OrType new(union)
end

def OrType canAssignFrom(other IType -> Bool)
    if other type == OrType then
        // It's also an or, so see if all of its cases are matched by one of
        // the ones here.
        for otherCase = other cases do
            if canAssignFrom(otherCase) not then return false
        end
        true
    else
        // It's a regular class, so see if any of the cases match it.
        for type = cases do
            if type canAssignFrom(other) then return true
        end
        false
    end
end
