import("Array.mag")
import("Int.mag")
import("String.mag")
import("Tuple.mag")
import("Types.mag")

// Extend the built-in classes.
extend class Object
    !=(other -> Bool) (this == other) not

    // Provide a generic print that converts arg to string first.
    print(arg Object ->) printRaw(arg string)
end

Object defineGetter("string", fn(-> String) "object")
String defineGetter("string", fn(-> String) this)
Nothing defineGetter("string", fn(-> String) "nothing")
Class defineGetter("string", fn(-> String) name)

// Truthiness.
Object defineGetter("true?", fn(-> Bool) true)
Bool defineGetter("true?", fn(-> Bool) this)
Int defineGetter("true?", fn(-> Bool) this != 0)
String defineGetter("true?", fn(-> Bool) this count > 0)
Nothing defineGetter("true?", fn(-> Bool) false)

// TODO(bob): Hack. This fixes a weird infinite regress problem. Let's say you
// have an expression like:
//
//   foo()
//
// It turns out "foo" is undefined. So when we evaluate "foo" , we fail to find
// it and return nothing. Then we try to evaluate "nothing()" (the apply).
// nothing is not a function, so that gets translated to "nothing call()". So
// we look up "call" on nothing, which fails, returning "nothing". Now we try
// to evaluate "nothing()"... stack overflow.
//
// This short-circuits that by actually making nothing callable.
extend class Nothing
    call(arg) nothing
end