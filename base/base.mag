import("Array.mag")
import("Function.mag")
import("Int.mag")
import("Interface.mag")
import("String.mag")
import("Tuple.mag")
import("Types.mag")
import("Type.mag")
import("OrType.mag")

// Returns the argument cast to the given type if it's type is an exact match
// and not a subtype, otherwise returns nothing.
// TODO(bob): Make this a method on Object so you can do: foo asExactly[Bar]
var asExactly[T](arg -> T | Nothing)
    if arg type == T then unsafecast[T](arg)
end

// Returns the argument cast to the given type if it can be safely assigned to
// that type, otherwise returns nothing.
// TODO(bob): Make this a method on Object so you can do: foo as[Bar]
var as[T](arg -> T | Nothing)
    var type = unsafecast[Type](arg type)
    if type == T then return unsafecast[T](arg)
    if T canAssignFrom(type) then unsafecast[T](arg)
end

// Extend the built-in classes.
extend class Object
    def !=(other -> Bool) = (this == other) not

    // Provide a generic print that converts arg to string first.
    def print(arg Object ->) = printRaw(arg string)
end

extend class Object
    get string String = "object"
end

extend class String
    get string String = this
end

extend class Nothing
    get string String = "nothing"
end

extend class Class
    get string String = name
end

// Truthiness.
extend class Object
    get true? Bool = true
end

extend class Bool
    get true? Bool = this
end

extend class Int
    get true? Bool = this != 0
end

extend class String
    get true? Bool = this count > 0
end

extend class Nothing
    get true? Bool = false
end

// TODO(bob): Hack. This fixes a weird infinite regress problem. Let's say you
// have an expression like:
//
//   foo()
//
// It turns out "foo" is undefined. So when we evaluate "foo" , we fail to find
// it and return nothing. Then we try to evaluate "nothing()" (the apply).
// nothing is not a function, so that gets translated to "nothing call()". So
// we look up "call" on nothing, which fails, returning "nothing". Now we try
// to evaluate "nothing()"... stack overflow.
//
// This short-circuits that by actually making nothing callable.
extend class Nothing
    def call(arg) = nothing
end