// These define the key operations on types that type checking is implemented
// in terms of. The most important part is "canAssignFrom". All types (objects)
// that can be the result of a type expression) are expect to implement this
// and return true if an argument of the given type would be OK in a variable
// defined to be that type.
// 
// For example, "Int canAssignFrom(Bool)" returns false since an Int variable
// can't hold a Bool. Given a class Base and a derived class Derived,
// "Base canAssignFrom(Derived)" returns true since every Derived is also a
// Base.

import("OrType.mag")
import("Function.mag")

// No type except Nothing is allowed where Nothing is expected.
shared Nothing canAssignFrom(other -> Bool) other == Nothing

shared Class unsafeRemoveNothing(-> Class)
    // Doesn't have Nothing to begin with, so we're good.
    this
end

// TODO(bob): Return Dynamic here is lame. Need type interface.
shared Class orTypes(left, right -> Dynamic)
    // combine the cases of both arms
    var cases = []

    if left type == OrType then
        for item = left cases do cases add(item)
    else
        cases add(left)
    end

    if right type == OrType then
        for item = right cases do cases add(item)
    else
        cases add(right)
    end

    // Sort and remove the duplicates.
    cases = cases sortByString unique

    // If just one case remains, there's no union.
    if cases count == 1 then return cases[0]
    
    OrType new(cases)
end

def Class canAssignFrom(other -> Bool)
    // Not even object can assign from Nothing.
    if other == Nothing then return false
    
    if other type == OrType then return false
    
    // A derived type can be assigned to a base type, so walk up the chain
    // looking for this type.
    while other != Object do
        if this == other then return true
        // Bail if got stuck in an infinite loop.
        if other == nothing then return false
        other = other parent
    end
    
    // If we got here, the only thing other has in common is Object, so see if
    // that's us.
    this == Object
end

def Class |(other -> Dynamic)
    Class orTypes(this, other)
end

def Tuple canAssignFrom(other -> Bool)
    // Both must be tuples.
    if other type != Tuple then return false
    
    // With the same number of fields.
    if count != Int unsafeCast(other count) then return false
    
    // And the fields must be assignable.
    for field = this
    for otherField = other do
        if field canAssignFrom(otherField) not then return false
    end
    
    true
end

shared Dynamic canAssignFrom(other -> Bool)
    // Everything goes with Dynamic.
    true
end

// TODO(bob): Should return IType
shared Dynamic getMethodType(name String, argType -> Dynamic)
    // A dynamic object accepts all methods and they all take and return Dynamic
    Dynamic, Dynamic
end
