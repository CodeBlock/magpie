// These define the key operations on types that type checking is implemented
// in terms of. The most important part is "canAssignFrom". All types (objects)
// that can be the result of a type expression) are expect to implement this
// and return true if an argument of the given type would be OK in a variable
// defined to be that type.
// 
// For example, "Int canAssignFrom(Bool)" returns false since an Int variable
// can't hold a Bool. Given a class Base and a derived class Derived,
// "Base canAssignFrom(Derived)" returns true since every Derived is also a
// Base.

// No type except Nothing is allowed where Nothing is expected.
shared Nothing canAssignFrom(other -> Bool) other == Nothing

shared Class orTypes(left, right ->)
    // combine the cases of both arms
    var cases = []

    if left type == OrType then
        for item = left cases do cases add(item)
    else
        cases add(left)
    end

    if right type == OrType then
        for item = right cases do cases add(item)
    else
        cases add(right)
    end

    // Sort and remove the duplicates.
    cases = cases sortByString unique

    // If just one case remains, there's no union.
    if cases count == 1 then return cases[0]
    
    OrType new(cases)
end

def Class canAssignFrom(other -> Bool)
    // Not even object can assign from Nothing.
    if other == Nothing then return false
    
    if other type == OrType then return false
    
    // A derived type can be assigned to a base type, so walk up the chain
    // looking for this type.
    while other != Object do
        if this == other then return true
        // Bail if got stuck in an infinite loop.
        if other == nothing then return false
        other = other parent
    end
    
    // If we got here, the only thing other has in common is Object, so see if
    // that's us.
    this == Object
end

def Class |(other -> OrType)
    Class orTypes(this, other)
end


class OrType
    this(cases)
        this cases = cases
    end
    
    cases Array // TODO(bob): Array of(IType)
end

def OrType toString(-> String)
    var result = ""
    for index = 0 until(cases count) do
        result = result + cases[index] toString
        if index < (cases count - 1) then result = result + " | "
    end
    result
end

def OrType |(other -> OrType)
    Class orTypes(this, other)
end

def OrType canAssignFrom(other -> Bool)
    if other type == OrType then
        // It's also an or, so see if all of its cases are matched by one of
        // the ones here.
        for otherCase = other cases do
            if canAssignFrom(otherCase) not then return false
        end
        true
    else
        // It's a regular class, so see if any of the cases match it.
        for type = cases do
            if type canAssignFrom(other) then return true
        end
        false
    end
end

def Tuple canAssignFrom(other -> Bool)
    // Both must be tuples.
    if other type != Tuple then return false
    
    // With the same number of fields.
    if count != other count then return false
    
    // And the fields must be assignable.
    for field = this
    for otherField = other do
        if field canAssignFrom(otherField) not then return false
    end
    
    true
end

shared Dynamic canAssignFrom(other -> Bool)
    // Everything goes with Dynamic.
    true
end
