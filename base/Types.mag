// These define the key operations on types that type checking is implemented
// in terms of. The most important part is "canAssignFrom". All types (objects)
// that can be the result of a type expression) are expect to implement this
// and return true if an argument of the given type would be OK in a variable
// defined to be that type.
// 
// For example, "Int canAssignFrom(Bool)" returns false since an Int variable
// can't hold a Bool. Given a class Base and a derived class Derived,
// "Base canAssignFrom(Derived)" returns true since every Derived is also a
// Base.

def Object is(type Type -> Bool) type canAssignFrom(this type)

extend class Nothing
    // No type except Nothing is allowed where Nothing is expected.
    shared def canAssignFrom(other Type -> Bool) other == Nothing
end

extend class Class
    // TODO(bob): Should this be part of Type?
    shared def unsafeRemoveNothing(-> Class)
        // Doesn't have Nothing to begin with, so we're good.
        this
    end

    def canAssignFrom(other Type -> Bool)
        // Short-circuit on self-assignment.
        if other == this then return true

        // Not even object can assign from Nothing.
        if other == Nothing then return false
    
        // If it's an Or type, just check the arms.
        let orType = asExactly[OrType](other) then
            for otherCase = orType cases do
                if canAssignFrom(otherCase) not then return false
            end
            return true
        end
        
        // A derived type can be assigned to a base type, so walk up the chain
        // looking for this type.
        var otherClass = unsafecast[Class](other)
        while otherClass != Object do
            if this == otherClass then return true
            // Bail if got stuck in an infinite loop.
            if otherClass == nothing then return false
            otherClass = otherClass parent
        end
    
        // If we got here, the only thing other has in common is Object, so see
        // if that's us.
        this == Object
    end
end

extend class Dynamic
    shared def canAssignFrom(other Type -> Bool)
        // Everything goes with Dynamic.
        true
    end

    // From the static perspective, a dynamic object has all possible members
    // and their type is always "Dynamic".
    shared def getMemberType(name String -> Type | Nothing)
        match name
        case "canAssignFrom" then Type => Bool
        case "getMemberType" then String => (Type | Nothing)
        case "getSetterType" then String => (Type | Nothing)
        case "call"          then Dynamic => Dynamic
        case "string"        then String
        case "type"          then Type
        case "=="            then Dynamic => Bool
        case "!="            then Dynamic => Bool
        case "|"             then Type => Type
        case "=>"            then Type => Type
        else                      Dynamic
        end
    end
end
