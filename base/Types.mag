// These define the key operations on types that type checking is implemented
// in terms of. The most important part is "canAssignFrom". All types (objects)
// that can be the result of a type expression) are expect to implement this
// and return true if an argument of the given type would be OK in a variable
// defined to be that type.
// 
// For example, "Int canAssignFrom(Bool)" returns false since an Int variable
// can't hold a Bool. Given a class Base and a derived class Derived,
// "Base canAssignFrom(Derived)" returns true since every Derived is also a
// Base.

import("OrType.mag")
import("Function.mag")
import("Interface.mag")

interface Type
    canAssignFrom(other Type -> Bool)
    getMemberType(name String -> Type | Nothing)
    getSetterType(name String -> Type | Nothing)
    string String
    type Type
    ==(other -> Bool)
    !=(other -> Bool)
    |(other Type -> Type)
end

// Returns the argument cast to the given type if it's type is an exact match
// and not a subtype, otherwise returns nothing.
// TODO(bob): Make this a method on Object so you can do: foo asExactly[Bar]
var asExactly[T](arg -> T | Nothing)
    if arg type == T then unsafecast[T](arg)
end

// Returns the argument cast to the given type if it can be safely assigned to
// that type, otherwise returns nothing.
// TODO(bob): Make this a method on Object so you can do: foo as[Bar]
var as[T](arg -> T | Nothing)
    var type = unsafecast[Type](arg type)
    if type == T then return unsafecast[T](arg)
    if T canAssignFrom(type) then unsafecast[T](arg)
end

extend class Object
    is(type Type -> Bool) type canAssignFrom(this type)
end

extend class Nothing
    // No type except Nothing is allowed where Nothing is expected.
    shared canAssignFrom(other Type -> Bool) other == Nothing
end

extend class Class
    // TODO(bob): Should this be part of Type?
    shared unsafeRemoveNothing(-> Class)
        // Doesn't have Nothing to begin with, so we're good.
        this
    end

    canAssignFrom(other Type -> Bool)
        // Short-circuit on self-assignment.
        if other == this then return true

        // Not even object can assign from Nothing.
        if other == Nothing then return false
    
        // If it's an Or type, just check the arms.
        let orType = asExactly[OrType](other) then
            for otherCase = orType cases do
                if canAssignFrom(otherCase) not then return false
            end
            return true
        end
        
        // A derived type can be assigned to a base type, so walk up the chain
        // looking for this type.
        var otherClass = unsafecast[Class](other)
        while otherClass != Object do
            if this == otherClass then return true
            // Bail if got stuck in an infinite loop.
            if otherClass == nothing then return false
            otherClass = otherClass parent
        end
    
        // If we got here, the only thing other has in common is Object, so see
        // if that's us.
        this == Object
    end

    |(other Type -> Type)
        OrType combine(this, other)
    end
end

extend class Dynamic
    shared canAssignFrom(other Type -> Bool)
        // Everything goes with Dynamic.
        true
    end

    // From the static perspective, a dynamic object has all possible members
    // and their type is always "Dynamic".
    shared getMemberType(name String -> Type | Nothing)
        // TODO(bob): This stuff is super hackish.
        if name == "canAssignFrom" then return Function(Type, Bool)
        if name == "getMemberType" then return Function(String, Type | Nothing)
        if name == "getSetterType" then return Function(String, Type | Nothing)
        if name == "call" then return Function(Dynamic, Dynamic)
        if type == "type" then return Type
        
        Dynamic
    end
end
