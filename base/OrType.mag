class OrType
    this(cases ArrayType new(Type))
        this cases = cases
    end
    
    shared combine(left Type, right Type -> Type)
        // combine the cases of both arms
        var cases = Array new()

        let leftOr = as[OrType](left) then
            for item = leftOr cases do cases add(item)
        else cases add(left)

        let rightOr = as[OrType](right) then
            for item = rightOr cases do cases add(item)
        else cases add(right)

        // Sort and remove the duplicates.
        cases = cases sortByString() unique()

        // If just one case remains, there's no union.
        if cases count == 1 then return cases(0)
    
        OrType new(cases)
    end

    |(other Type -> Type)
        OrType combine(this, other)
    end

    ==(other -> Bool)
        let orType = as[OrType](other) then
            if cases count != orType cases count then return false
    
            for thisCase = cases
            for otherCase = orType cases do
                if thisCase != otherCase then return false
            end
            true
        else false
    end

    !=(other -> Bool) (this == other) not

    canAssignFrom(other Type -> Bool)
        let orType = as[OrType](other) then
            // It's also an or, so see if all of its cases are matched by one of
            // the ones here.
            for otherCase = orType cases do
                if canAssignFrom(otherCase) not then return false
            end
            true
        else
            // It's a regular class, so see if any of the cases match it.
            for type = cases do
                if type canAssignFrom(other) then return true
            end
            false
        end
    end

    getMemberType(name String -> Type | Nothing)
        let firstType = cases(0) getMemberType(name) then
            for type = cases do
                // The method must be present in all cases.
                let method = type getMemberType(name) then
                    // All types must match.
                    // TODO(bob): Right now, the types of all cases must match
                    // exactly. We could loosen this to allow subtypes.
                    if firstType canAssignFrom(method) not then return nothing
                    if method canAssignFrom(firstType) not then return nothing
                else return nothing
            end
            
            return firstType
        end
    end

    getSetterType(name String -> Type | Nothing)
        let firstType = cases(0) getMemberType(name) then
            for type = cases do
                let method = type getSetterType(name) then
                    // All types must match.
                    // TODO(bob): Right now, the types of all cases must match
                    // exactly. We could loosen this to allow subtypes.
                    if firstType canAssignFrom(method) not then return nothing
                    // TODO(bob): Block if here is to get around grammar
                    // confusing 'else' with being for this 'if'.
                    if method canAssignFrom(firstType) not then return nothing
                else
                    // The setter must be present in all cases
                    return nothing
                end
            end
    
            return firstType
        end
    end

    unsafeRemoveNothing(-> Type)
        // TODO(bob): Total hack. We need remaining to have the right element
        // type.
        var remaining = cases copy()
        remaining clear()
        
        for type = cases do
            if type != Nothing then remaining add(type)
        end

        // If just one case remains, there's no or.
        if remaining count == 1 then return remaining(0)
    
        // Create a new OrType with what's left.
        OrType new(remaining)
    end
    
    cases ArrayType new(Type)
end

OrType defineGetter("string", fn(-> String)
    var result = ""
    for index = 0 until(cases count) do
        result = result + cases(index) string
        if index < (cases count - 1) then result = result + " | "
    end
    result
end)
