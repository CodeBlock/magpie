class OrType
    this(cases ArrayType new(Type)) =
        this cases = cases
    end
    
    shared def combine(left Type, right Type -> Type) =
        // combine the cases of both arms
        var cases = Array new()

        let leftOr = as[OrType](left) then
            for item = leftOr cases do cases add(item)
        else cases add(left)

        let rightOr = as[OrType](right) then
            for item = rightOr cases do cases add(item)
        else cases add(right)

        // Sort and remove the duplicates.
        cases = cases sortByString() unique()

        // If just one case remains, there's no union.
        if cases count == 1 then return cases(0)
    
        OrType new(cases)
    end

    get string String =
        var result = ""
        for index = 0 until(cases count) do
            result = result + cases(index) string
            if index < (cases count - 1) then result = result + " | "
        end
        result
    end

    def ==(other -> Bool) =
        let orType = as[OrType](other) then
            if cases count != orType cases count then return false
    
            for thisCase = cases
            for otherCase = orType cases do
                if thisCase != otherCase then return false
            end
            true
        else false
    end

    def !=(other -> Bool) = (this == other) not

    def canAssignFrom(other Type -> Bool) =
        let orType = as[OrType](other) then
            // It's also an or, so see if all of its cases are matched by one of
            // the ones here.
            for otherCase = orType cases do
                if canAssignFrom(otherCase) not then return false
            end
            true
        else
            // It's a regular class, so see if any of the cases match it.
            for type = cases do
                if type canAssignFrom(other) then return true
            end
            false
        end
    end

    def getMemberType(name String -> Type | Nothing) =
        let firstType = cases(0) getMemberType(name) then
            for type = cases do
                // The method must be present in all cases.
                let method = type getMemberType(name) then
                    // All types must match.
                    // TODO(bob): Right now, the types of all cases must match
                    // exactly. We could loosen this to allow subtypes.
                    if firstType canAssignFrom(method) not then return nothing
                    if method canAssignFrom(firstType) not then return nothing
                else return nothing
            end
            
            return firstType
        end
    end

    def getSetterType(name String -> Type | Nothing) =
        let firstType = cases(0) getMemberType(name) then
            for type = cases do
                let method = type getSetterType(name) then
                    // All types must match.
                    // TODO(bob): Right now, the types of all cases must match
                    // exactly. We could loosen this to allow subtypes.
                    if firstType canAssignFrom(method) not then return nothing
                    // TODO(bob): Block if here is to get around grammar
                    // confusing 'else' with being for this 'if'.
                    if method canAssignFrom(firstType) not then return nothing
                else
                    // The setter must be present in all cases
                    return nothing
                end
            end
    
            return firstType
        end
    end

    def unsafeRemoveNothing(-> Type) =
        // TODO(bob): Total hack. We need remaining to have the right element
        // type.
        var remaining = cases copy()
        remaining clear()
        
        for type = cases do
            if type != Nothing then remaining add(type)
        end

        // If just one case remains, there's no or.
        if remaining count == 1 then return remaining(0)
    
        // Create a new OrType with what's left.
        OrType new(remaining)
    end
    
    var cases ArrayType new(Type)
end

// Extend all types to support unioning:

extend interface Type
    def |(other Type -> Type)
end

def ArrayType |(other Type -> Type) OrType combine(this, other)
def ArrayIteratorType |(other Type -> Type) OrType combine(this, other)
def Class |(other Type -> Type) OrType combine(this, other)
def FunctionType |(other Type -> Type) OrType combine(this, other)
def Interface |(other Type -> Type) OrType combine(this, other)
def OrType |(other Type -> Type) OrType combine(this, other)
def Tuple |(other Type -> Type) OrType combine(this, other)
