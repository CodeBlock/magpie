class OrType
    shared def new(cases ArrayType new(Type) -> OrType)
        signify(cases: cases)
    end
    
    shared def combine(left Type, right Type -> Type)
        // combine the cases of both arms
        var cases = Array new()

        let leftOr = left as[OrType] then
            for item = leftOr cases do cases add(item)
        else cases add(left)

        let rightOr = right as[OrType] then
            for item = rightOr cases do cases add(item)
        else cases add(right)

        // Sort and remove the duplicates.
        cases = cases sortByString() unique()

        // If just one case remains, there's no union.
        if cases count == 1 then return cases(0)
    
        OrType new(cases)
    end

    get string String =
        var result = ""
        for index = 0 until(cases count) do
            result = result + cases(index) string
            if index < (cases count - 1) then result = result + " | "
        end
        result
    end

    def ==(other -> Bool)
        let orType = other as[OrType] then
            if cases count != orType cases count then return false
    
            for thisCase = cases
            for otherCase = orType cases do
                if thisCase != otherCase then return false
            end
            true
        else false
    end

    def !=(other -> Bool) (this == other) not

    def assignsFrom?(other Type -> Bool)
        let orType = other as[OrType] then
            // It's also an or, so see if all of its cases are matched by one of
            // the ones here.
            for otherCase = orType cases do
                if assignsFrom?(otherCase) not then return false
            end
            true
        else
            // It's a regular class, so see if any of the cases match it.
            for type = cases do
                if type assignsFrom?(other) then return true
            end
            false
        end
    end

    def getMemberType(name String -> Type)
        // Union the member types of all of the cases.
        var memberType = cases(0) getMemberType(name)
        for i = 1 until(cases count) do
            memberType = memberType | cases(i) getMemberType(name)
        end
        
        memberType
    end

    def getSetterType(name String -> Type | Nothing)
        let firstType = cases(0) getSetterType(name) then
            for type = cases do
                let method = type getSetterType(name) then
                    // All types must match.
                    // TODO(bob): Right now, the types of all cases must match
                    // exactly. We could loosen this to allow subtypes.
                    if firstType assignsFrom?(method) not then return nothing
                    // TODO(bob): Block if here is to get around grammar
                    // confusing 'else' with being for this 'if'.
                    if method assignsFrom?(firstType) not then return nothing
                else
                    // The setter must be present in all cases
                    return nothing
                end
            end
    
            return firstType
        end
    end

    def unsafeRemoveNothing(-> Type)
        // TODO(bob): Total hack. We need remaining to have the right element
        // type.
        var remaining = cases copy()
        remaining clear()
        
        for type = cases do
            if type != Nothing then remaining add(type)
        end

        // If just one case remains, there's no or.
        if remaining count == 1 then return remaining(0)
    
        // Create a new OrType with what's left.
        OrType new(remaining)
    end
    
    var cases ArrayType new(Type)
end

// Extend all types to support unioning:

extend interface Type
    def |(other Type -> Type)
end

def ArrayType         |(other Type -> Type) OrType combine(this, other)
def ArrayIteratorType |(other Type -> Type) OrType combine(this, other)
def Class             |(other Type -> Type) OrType combine(this, other)
def FunctionType      |(other Type -> Type) OrType combine(this, other)
def Interface         |(other Type -> Type) OrType combine(this, other)
def OrType            |(other Type -> Type) OrType combine(this, other)
def Tuple             |(other Type -> Type) OrType combine(this, other)
