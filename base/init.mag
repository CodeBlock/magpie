import("Array.mag")
import("Class.mag")
import("Function.mag")
import("Int.mag")
import("GenericInterface.mag")
import("Interface.mag")
import("Record.mag")
import("String.mag")
import("Tuple.mag")
import("Type.mag")
import("OrType.mag")
import("Error.mag")
import("Object.mag")
import("Stringable.mag")
import("Trueable.mag")

import("Iterator.mag")
import("List.mag")

import("syntax/init.mag")

interface Any
end

// TODO(bob): Hackish. Need to figure out what the semantics for this should be.
def ==(left, right -> Bool)
    // Must be equal if they're the same object.
    if Runtime same?(left, right) then return true
    
    // Must be the same class.
    var leftClass = Runtime getClass(left)
    var rightClass = Runtime getClass(right)
    if leftClass != rightClass then return false
    
    // Leave it up to the class to decide.
    let equalFunc = leftClass equal? then
        var equal = equalFunc(left, right)
        unsafecast[Bool](equal)
    else
        // Class doesn't provide an equality function, and they aren't the
        // same object, so default to not equal.
        false
    end
end

def !=(left, right -> Bool) (left == right) not

def <(left, right -> Bool)
    // Leave it up to the class to decide.
    let lessFunc = Runtime getClass(left) lessThan? then
        var less = lessFunc(left, right)
        less expecting[Bool]
    else
        false
    end
end

def >(left, right -> Bool)
    (left < right) not and left != right
end

def <=(left, right -> Bool)
    (left < right) or left == right
end

def >=(left, right -> Bool)
    (left < right) not
end

def +(left Int, right Int -> Int)
    Int add(left, right)
end

def ~(left Stringable, right Stringable -> String)
    left string concatenate(right string)
end

// Add an arrow operator to make function types out of other types:
def =>(left Type, right Type -> Type) FunctionType new(left, right, false)
