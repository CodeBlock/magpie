// expected: 1
// expected: 2
// expected: 3
// expected: should
// expected: 1
// expected: should
// expected: 2
// expected: should
// expected: 3
// expected: 4
// expected: five
// expected: 6
// expected: should

Main (->)
    let a <- None'Int then Print "should not"
    let a <- Some 1 then Print "1"
    
    let a <- None'Int
    then Print "should not"
    
    let a <- Some 2
    then Print "2"
    
    let a <- None'Int then
        Print "should not"
    end
    
    let a <- Some 3 then
        Print "3"
    end
    
    let a <- None'Int then Print "should not" else Print "should"
    let a <- Some 1 then Print "1" else Print "should not"
    
    let a <- None'Int
    then Print "should not"
    else Print "should"
    
    let a <- Some 2
    then Print "2"
    else Print "should not"
    
    let a <- None'Int then
        Print "should not"
    else
        Print "should"
    end
    
    let a <- Some 3 then
        Print "3"
    else
        Print "should not"
    end
    
    // tuple splitting
    let a, b, c <- Some (4, "five", 6) then
        Print a.String
        Print b.String
        Print c.String
    else
        Print "should not"
    end
    
    //### bob: the double (()) here is lame. it's because a single
    // () is used to define the type argument list itself. to pass in
    // a *single* type argument whose type is a tuple, double parens
    // are needed. that's lame. need to fix the syntax here. :(
    let a, b, c <- None'((Int, String, Bool)) then
        Print "should not"
    else
        Print "should"
    end
end
