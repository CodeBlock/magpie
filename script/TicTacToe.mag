using System

Main (->)
    mutable playing <- true
    def     board   <- Board
    
    while playing do
        Draw board
        Console:Write "Move? "
        
        def move <- Console:ReadLine
        
        if move = "q" then playing <- false
        else if move = "1" then Move (board, 0, 0)
        else if move = "2" then Move (board, 1, 0)
        else if move = "3" then Move (board, 2, 0)
        else if move = "4" then Move (board, 0, 1)
        else if move = "5" then Move (board, 1, 1)
        else if move = "6" then Move (board, 2, 1)
        else if move = "7" then Move (board, 0, 2)
        else if move = "8" then Move (board, 1, 2)
        else if move = "9" then Move (board, 2, 2)
        
        if Not board.PlayersTurn? then CpuMove board
    end
end

Draw (board Board ->)
    Console:Clear
    Print ""
    Print (" " + board.(0, 0).String + "|" + board.(1, 0).String + "|" + board.(2, 0).String)
    Print " ---+---+---"
    Print (" " + board.(0, 1).String + "|" + board.(1, 1).String + "|" + board.(2, 1).String)
    Print " ---+---+---"
    Print (" " + board.(0, 2).String + "|" + board.(1, 2).String + "|" + board.(2, 2).String)
    Print ""
end

Move (board Board, x Int, y Int ->)
    def side <- if board.PlayersTurn? then X else O
    
    if Not board.(x, y).Empty? then
        Console:Write "Can't move there! (press enter to continue)"
        Ignore Console:ReadLine
    else board.(x, y) <- side
    
    // next side's turn
    board.PlayersTurn? <- .Not
end

CpuMove (board Board ->)
    Print "cpu move"
end

CheckWin (board Board, positions []'(Int, Int) ->)
    mutable numX <- 0
    mutable numO <- 0
    
    for pos <- positions do
        if board.pos.X? then numX <- + 1
        if board.pos.O? then numO <- + 1
    end
    
    if numX = 3 then Print "X won!"
    if numO = 3 then Print "O won!"
end

Board (-> Board)
    Board (true, [Empty, Empty, Empty,
                  Empty, Empty, Empty,
                  Empty, Empty, Empty])
end

String (cell Cell -> String)
    //### bob: pattern matching would be nice
    if cell.Empty? then "   "
    else if cell.X? then " X "
    else " O "
end

// treat a board like a 2d-array of cells
__Call (pos (Int, Int), board Board -> Cell)
    def index <- (pos.Y * 3) + pos.X
    board.Cells.index
end

__Call<- (pos (Int, Int), board Board, cell Cell ->)
    def index <- (pos.Y * 3) + pos.X
    board.Cells.index <- cell
end

// pull out tuple fields
X (a Int, b Int -> Int) a
Y (a Int, b Int -> Int) b

Ignore'T (a T ->) ()

union Cell
    Empty
    X
    O
end

struct Board
    PlayersTurn?    mutable Bool
    Cells           []!'Cell
end

// array iterators

Iterate'T (array []'T -> Array^'T) Array^ (array, 0)

MoveNext'T (iter Array^'T -> Bool)
    iter.Index <- + 1
    iter.Index < iter.Array.Size
end

Current'T (iter Array^'T -> T)
    def index <- iter.Index
    iter.Array.index 
end

struct Array^'T
    Array []'T
    Index mutable Int
end
