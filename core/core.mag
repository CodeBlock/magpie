defclass Bool native
defclass Channel native
defclass Char native
defclass Class native
defclass Function native
defclass List native
defclass Nothing native
defclass Num native
defclass Record native
defclass String native

defclass NoMatchError
end

defclass NoMethodError
end

defclass ArgError
    /// Error thrown when an invalid argument is passed to a method. This can
    /// be because the argument is never valid for a method, or because the
    /// argument's current state is invalid.
end

defclass UndefinedVarError
end

// TODO(bob): Make native so users can't construct their own instances.
defclass Done
end

val done = Done new

def (is Done) toString
    "done"
end

def (is Num) + (is Num) native "numPlusNum"
def (is Num) - (is Num) native "numMinusNum"
def (is Num) * (is Num) native "numTimesNum"
def (is Num) / (is Num) native "numDivNum"
def (is Num) % (is Num) native "numModNum"

def (is Num) < (is Num) native "numLessThanNum"
def (is Num) <= (is Num) native "numLessThanEqualToNum"
def (is Num) > (is Num) native "numGreaterThanNum"
def (is Num) >= (is Num) native "numGreaterThanEqualToNum"

def (is String) + (is String) native "stringPlusString"
def (left) + (right is String)
    left toString + right
end
def (left is String) + (right)
    left + right toString
end

def print(arg)
    print(arg toString)
    arg
end

def print(arg is String) native "printString"

def (_) class native "objectClass"

def (is String) count native "stringCount"

def (_) toString native "objectToString"

def (true) toString "true"
def (false) toString "false"

def (is Num) toString native "numToString"
def (s is String) toString s

def (is Channel) close native "channelClose"
def (is Channel) isOpen native "channelIsOpen"
def (== Channel) new native "channelNew"
def (is Channel) receive native "channelReceive"
def (is Channel) send(value) native "channelSend"

// Channels are themselves iterators, so iterating it returns itself.
def (channel is Channel) iterate
    channel
end

def (channel is Channel) advance
    channel receive
end

// TODO(bob): How should different argument patterns be handled?
def (is Function) call native "functionCall"

def (is List) add(item) native "listAdd"
def (is List) count native "listCount"

def (list is List) _boundsCheck(index is Num)
    // Negative indices index backwards from the end.
    if index < 0 then index = list count + index

    // Check bounds.
    if index < 0 then throw ArgError new
    if index >= list count then throw ArgError new

    index
end

def (list is List)[index is Num]
    list _index(list _boundsCheck(index))
end

def (is List) _index(is Num) native "listIndex"

def (list is List)[index is Num]=(value)
    list _indexSet(list _boundsCheck(index), value)
end

def (is List) _indexSet(index is Num, value) native "listIndexSet"

def (list is List)[range is Range]
    val first = range first
    val last = range last + (if range inclusive then 1 else 0)

    if first < 0 or first > list count or
        last < 0 or last > list count then throw ArgError new

    list _indexRange(first, last)
end

def (is List) _indexRange(first is Num, last is Num) native "listIndexRange"

def (is List) insert(item, at: index is Num) native "listInsert"

// Makes lists iterable.
defclass ListIterator
    val list is List
    var index
end

def (list is List) iterate
    ListIterator new(list: list, index: -1)
end

def (iterator is ListIterator) advance
    iterator index = iterator index + 1
    if iterator index >= iterator list count then
        done
    else
        iterator list[iterator index]
    end
end

defclass Range
    val first is Num
    val last is Num
    val inclusive is Bool
end

def (== Range) new(first: first is Num, last: last is Num)
    Range new(first: first, last: last, inclusive: true)
end

def (first is Num) .. (last is Num)
    Range new(first: first, last: last)
end

def (first is Num) ... (last is Num)
    Range new(first: first, last: last, inclusive: false)
end

def (range is Range) iterate
    var last = range last
    if not range inclusive  then last = last - 1
    RangeIterator new(current: range first - 1, last: last)
end

defclass RangeIterator
    var current is Num
    val last is Num
end

def (iterator is RangeIterator) advance
    if iterator current + 1 > iterator last then
        done
    else
        iterator current = iterator current + 1
    end
end

// Now that everything is defined, wire it up to the VM.
def _bindCore() native "bindCore"
_bindCore()
