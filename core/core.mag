defclass Bool native
defclass Channel native
defclass Char native
defclass Class native
defclass Function native
defclass List native
defclass Nothing native
defclass Num native
defclass Float is Num native
defclass Int is Num native
defclass Record native
defclass String native

defclass NoMatchError
end

defclass NoMethodError
end

defclass ArgError
    /// Error thrown when an invalid argument is passed to a method. This can
    /// be because the argument is never valid for a method, or because the
    /// argument's current state is invalid.
end

defclass UndefinedVarError
end

// TODO(bob): Make native so users can't construct their own instances.
defclass Done
end

val done = Done new

def (is Done) toString
    "done"
end

def (is Int) + (is Int) native "intPlusInt"
def (is Int) + (is Float) native "intPlusFloat"
def (is Float) + (is Int) native "floatPlusInt"
def (is Float) + (is Float) native "floatPlusFloat"

def (is Int) - (is Int) native "intMinusInt"
def (is Int) - (is Float) native "intMinusFloat"
def (is Float) - (is Int) native "floatMinusInt"
def (is Float) - (is Float) native "floatMinusFloat"

def (is Int) * (is Int) native "intTimesInt"
def (is Int) * (is Float) native "intTimesFloat"
def (is Float) * (is Int) native "floatTimesInt"
def (is Float) * (is Float) native "floatTimesFloat"

def (is Int) / (is Int) native "intDivInt"
def (is Int) / (is Float) native "intDivFloat"
def (is Float) / (is Int) native "floatDivInt"
def (is Float) / (is Float) native "floatDivFloat"

// TODO(bob): What about floating point modulo?
def (is Int) % (is Int) native "intModInt"

def (is Int) <=> (is Int) native "intCompareToInt"
def (is Int) <=> (is Float) native "intCompareToFloat"
def (is Float) <=> (is Int) native "floatCompareToInt"
def (is Float) <=> (is Float) native "floatCompareToFloat"

def (is Int) sgn native "intSgn"
def (is Float) sgn native "floatSgn"

def (a) < (b)
    a <=> b == -1
end

def (a) <= (b)
    a <=> b != 1
end

def (a) > (b)
    a <=> b == 1
end

def (a) >= (b)
    a <=> b != -1
end

def (is String) + (is String) native "stringPlusString"
def (left) + (right is String)
    left toString + right
end
def (left is String) + (right)
    left + right toString
end

def (left is String) * (right is Int)
    if right < 0 then throw ArgError new
    // TODO(bob): Use some kind of string builder?
    var result = ""
    for _ in 1..right do result = result + left
    result
end

def print(arg)
    print(arg toString)
    arg
end

def print(arg is String) native "printString"

def (_) class native "objectClass"

def (is String) count native "stringCount"

def (string is String)[index is Int]
    string _subscript(_boundsCheck(string count, index))
end

def (is String) _subscript(is Int) native "stringSubscriptInt"

def (_) toString native "objectToString"

def (true) toString "true"
def (false) toString "false"

def (is Int) toString native "intToString"
def (is Float) toString native "floatToString"
def (s is String) toString s

def (is Channel) close native "channelClose"
def (is Channel) isOpen native "channelIsOpen"
def (== Channel) new native "channelNew"
def (is Channel) receive native "channelReceive"
def (is Channel) send(value) native "channelSend"

// Channels are themselves iterators, so iterating it returns itself.
def (channel is Channel) iterate
    channel
end

def (channel is Channel) advance
    channel receive
end

// TODO(bob): How should different argument patterns be handled?
def (is Function) call native "functionCall"

def (is List) add(item) native "listAdd"
def (is List) count native "listCount"

def _boundsCheck(count is Int, index is Int)
    // Negative indices index backwards from the end.
    if index < 0 then index = count + index

    // Check bounds.
    if index < 0 then throw ArgError new
    if index >= count then throw ArgError new

    index
end

def (list is List)[index is Int]
    list _subscript(_boundsCheck(list count, index))
end

def (is List) _subscript(is Int) native "listSubscriptInt"

def (list is List)[index is Int]=(value)
    list _subscriptSet(_boundsCheck(list count, index), value)
end

def (is List) _subscriptSet(index is Int, value) native "listSubscriptSetInt"

def (list is List)[range is Range]
    val first = range first
    val last = range last + (if range inclusive then 1 else 0)

    if first < 0 or first > list count or
        last < 0 or last > list count then throw ArgError new

    list _subscript(first, last)
end

def (is List) _subscript(first is Int, last is Int) native "listSubscriptRange"

def (is List) insert(item, at: index is Int) native "listInsert"

// Makes lists iterable.
defclass ListIterator
    val list is List
    var index is Int
end

def (list is List) iterate
    ListIterator new(list: list, index: -1)
end

def (iterator is ListIterator) advance
    iterator index = iterator index + 1
    if iterator index >= iterator list count then
        done
    else
        iterator list[iterator index]
    end
end

// TODO(bob): What about floating point ranges?
defclass Range
    val first is Int
    val last is Int
    val inclusive is Bool
end

def (== Range) new(first: first is Int, last: last is Int)
    Range new(first: first, last: last, inclusive: true)
end

def (first is Int) .. (last is Int)
    Range new(first: first, last: last)
end

def (first is Int) ... (last is Int)
    Range new(first: first, last: last, inclusive: false)
end

def (range is Range) iterate
    var last = range last
    if not range inclusive  then last = last - 1
    RangeIterator new(current: range first - 1, last: last)
end

defclass RangeIterator
    var current is Int
    val last is Int
end

def (iterator is RangeIterator) advance
    if iterator current + 1 > iterator last then
        done
    else
        iterator current = iterator current + 1
    end
end

// Now that everything is defined, wire it up to the VM.
def _bindCore() native "bindCore"
_bindCore()
