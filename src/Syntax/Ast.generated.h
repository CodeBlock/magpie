// Automatically generated by script/generate_ast.py.
// Do not hand-edit.

class AndExpr;
class BinaryOpExpr;
class BoolExpr;
class CallExpr;
class CatchExpr;
class DefMethodExpr;
class DoExpr;
class IfExpr;
class IsExpr;
class MatchExpr;
class NameExpr;
class NotExpr;
class NothingExpr;
class NumberExpr;
class OrExpr;
class RecordExpr;
class ReturnExpr;
class SequenceExpr;
class StringExpr;
class ThrowExpr;
class VariableExpr;
class RecordPattern;
class TypePattern;
class ValuePattern;
class VariablePattern;
class WildcardPattern;

class ExprVisitor
{
public:
  virtual ~ExprVisitor() {}

  virtual void visit(const AndExpr& node, int dest) = 0;
  virtual void visit(const BinaryOpExpr& node, int dest) = 0;
  virtual void visit(const BoolExpr& node, int dest) = 0;
  virtual void visit(const CallExpr& node, int dest) = 0;
  virtual void visit(const CatchExpr& node, int dest) = 0;
  virtual void visit(const DefMethodExpr& node, int dest) = 0;
  virtual void visit(const DoExpr& node, int dest) = 0;
  virtual void visit(const IfExpr& node, int dest) = 0;
  virtual void visit(const IsExpr& node, int dest) = 0;
  virtual void visit(const MatchExpr& node, int dest) = 0;
  virtual void visit(const NameExpr& node, int dest) = 0;
  virtual void visit(const NotExpr& node, int dest) = 0;
  virtual void visit(const NothingExpr& node, int dest) = 0;
  virtual void visit(const NumberExpr& node, int dest) = 0;
  virtual void visit(const OrExpr& node, int dest) = 0;
  virtual void visit(const RecordExpr& node, int dest) = 0;
  virtual void visit(const ReturnExpr& node, int dest) = 0;
  virtual void visit(const SequenceExpr& node, int dest) = 0;
  virtual void visit(const StringExpr& node, int dest) = 0;
  virtual void visit(const ThrowExpr& node, int dest) = 0;
  virtual void visit(const VariableExpr& node, int dest) = 0;

protected:
  ExprVisitor() {}

private:
  NO_COPY(ExprVisitor);
};

// Base class for all AST node classes.
class Expr : public Managed
{
public:
  Expr(const SourcePos& pos)
  : pos_(pos)
  {}

  virtual ~Expr() {}

  // The visitor pattern.
  virtual void accept(ExprVisitor& visitor, int arg) const = 0;

  // Dynamic casts.
    virtual const AndExpr* asAndExpr() const { return NULL; }
  virtual const BinaryOpExpr* asBinaryOpExpr() const { return NULL; }
  virtual const BoolExpr* asBoolExpr() const { return NULL; }
  virtual const CallExpr* asCallExpr() const { return NULL; }
  virtual const CatchExpr* asCatchExpr() const { return NULL; }
  virtual const DefMethodExpr* asDefMethodExpr() const { return NULL; }
  virtual const DoExpr* asDoExpr() const { return NULL; }
  virtual const IfExpr* asIfExpr() const { return NULL; }
  virtual const IsExpr* asIsExpr() const { return NULL; }
  virtual const MatchExpr* asMatchExpr() const { return NULL; }
  virtual const NameExpr* asNameExpr() const { return NULL; }
  virtual const NotExpr* asNotExpr() const { return NULL; }
  virtual const NothingExpr* asNothingExpr() const { return NULL; }
  virtual const NumberExpr* asNumberExpr() const { return NULL; }
  virtual const OrExpr* asOrExpr() const { return NULL; }
  virtual const RecordExpr* asRecordExpr() const { return NULL; }
  virtual const ReturnExpr* asReturnExpr() const { return NULL; }
  virtual const SequenceExpr* asSequenceExpr() const { return NULL; }
  virtual const StringExpr* asStringExpr() const { return NULL; }
  virtual const ThrowExpr* asThrowExpr() const { return NULL; }
  virtual const VariableExpr* asVariableExpr() const { return NULL; }

  const SourcePos& pos() const { return pos_; }

private:
  SourcePos pos_;
};

class AndExpr : public Expr
{
public:
  AndExpr(const SourcePos& pos, gc<Expr> left, gc<Expr> right)
  : Expr(pos),
    left_(left),
    right_(right)
  {}

  virtual void accept(ExprVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const AndExpr* asAndExpr() const { return this; }

  gc<Expr> left() const { return left_; }
  gc<Expr> right() const { return right_; }

  virtual void reach()
  {
    Memory::reach(left_);
    Memory::reach(right_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> left_;
  gc<Expr> right_;
};

class BinaryOpExpr : public Expr
{
public:
  BinaryOpExpr(const SourcePos& pos, gc<Expr> left, TokenType type, gc<Expr> right)
  : Expr(pos),
    left_(left),
    type_(type),
    right_(right)
  {}

  virtual void accept(ExprVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const BinaryOpExpr* asBinaryOpExpr() const { return this; }

  gc<Expr> left() const { return left_; }
  TokenType type() const { return type_; }
  gc<Expr> right() const { return right_; }

  virtual void reach()
  {
    Memory::reach(left_);
    Memory::reach(right_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> left_;
  TokenType type_;
  gc<Expr> right_;
};

class BoolExpr : public Expr
{
public:
  BoolExpr(const SourcePos& pos, bool value)
  : Expr(pos),
    value_(value)
  {}

  virtual void accept(ExprVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const BoolExpr* asBoolExpr() const { return this; }

  bool value() const { return value_; }

  virtual void trace(std::ostream& out) const;

private:
  bool value_;
};

class CallExpr : public Expr
{
public:
  CallExpr(const SourcePos& pos, gc<Expr> leftArg, gc<String> name, gc<Expr> rightArg)
  : Expr(pos),
    leftArg_(leftArg),
    name_(name),
    rightArg_(rightArg)
  {}

  virtual void accept(ExprVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const CallExpr* asCallExpr() const { return this; }

  gc<Expr> leftArg() const { return leftArg_; }
  gc<String> name() const { return name_; }
  gc<Expr> rightArg() const { return rightArg_; }

  virtual void reach()
  {
    Memory::reach(leftArg_);
    Memory::reach(name_);
    Memory::reach(rightArg_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> leftArg_;
  gc<String> name_;
  gc<Expr> rightArg_;
};

class CatchExpr : public Expr
{
public:
  CatchExpr(const SourcePos& pos, gc<Expr> body, const Array<MatchClause>& catches)
  : Expr(pos),
    body_(body),
    catches_(catches)
  {}

  virtual void accept(ExprVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const CatchExpr* asCatchExpr() const { return this; }

  gc<Expr> body() const { return body_; }
  const Array<MatchClause>& catches() const { return catches_; }

  virtual void reach()
  {
    Memory::reach(body_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> body_;
  Array<MatchClause> catches_;
};

class DefMethodExpr : public Expr
{
public:
  DefMethodExpr(const SourcePos& pos, gc<Pattern> leftParam, gc<String> name, gc<Pattern> rightParam, gc<Expr> body)
  : Expr(pos),
    leftParam_(leftParam),
    name_(name),
    rightParam_(rightParam),
    body_(body)
  {}

  virtual void accept(ExprVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const DefMethodExpr* asDefMethodExpr() const { return this; }

  gc<Pattern> leftParam() const { return leftParam_; }
  gc<String> name() const { return name_; }
  gc<Pattern> rightParam() const { return rightParam_; }
  gc<Expr> body() const { return body_; }

  virtual void reach()
  {
    Memory::reach(leftParam_);
    Memory::reach(name_);
    Memory::reach(rightParam_);
    Memory::reach(body_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Pattern> leftParam_;
  gc<String> name_;
  gc<Pattern> rightParam_;
  gc<Expr> body_;
};

class DoExpr : public Expr
{
public:
  DoExpr(const SourcePos& pos, gc<Expr> body)
  : Expr(pos),
    body_(body)
  {}

  virtual void accept(ExprVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const DoExpr* asDoExpr() const { return this; }

  gc<Expr> body() const { return body_; }

  virtual void reach()
  {
    Memory::reach(body_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> body_;
};

class IfExpr : public Expr
{
public:
  IfExpr(const SourcePos& pos, gc<Expr> condition, gc<Expr> thenArm, gc<Expr> elseArm)
  : Expr(pos),
    condition_(condition),
    thenArm_(thenArm),
    elseArm_(elseArm)
  {}

  virtual void accept(ExprVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const IfExpr* asIfExpr() const { return this; }

  gc<Expr> condition() const { return condition_; }
  gc<Expr> thenArm() const { return thenArm_; }
  gc<Expr> elseArm() const { return elseArm_; }

  virtual void reach()
  {
    Memory::reach(condition_);
    Memory::reach(thenArm_);
    Memory::reach(elseArm_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> condition_;
  gc<Expr> thenArm_;
  gc<Expr> elseArm_;
};

class IsExpr : public Expr
{
public:
  IsExpr(const SourcePos& pos, gc<Expr> value, gc<Expr> type)
  : Expr(pos),
    value_(value),
    type_(type)
  {}

  virtual void accept(ExprVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const IsExpr* asIsExpr() const { return this; }

  gc<Expr> value() const { return value_; }
  gc<Expr> type() const { return type_; }

  virtual void reach()
  {
    Memory::reach(value_);
    Memory::reach(type_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> value_;
  gc<Expr> type_;
};

class MatchExpr : public Expr
{
public:
  MatchExpr(const SourcePos& pos, gc<Expr> value, const Array<MatchClause>& cases)
  : Expr(pos),
    value_(value),
    cases_(cases)
  {}

  virtual void accept(ExprVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const MatchExpr* asMatchExpr() const { return this; }

  gc<Expr> value() const { return value_; }
  const Array<MatchClause>& cases() const { return cases_; }

  virtual void reach()
  {
    Memory::reach(value_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> value_;
  Array<MatchClause> cases_;
};

class NameExpr : public Expr
{
public:
  NameExpr(const SourcePos& pos, gc<String> name)
  : Expr(pos),
    name_(name)
  {}

  virtual void accept(ExprVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const NameExpr* asNameExpr() const { return this; }

  gc<String> name() const { return name_; }

  virtual void reach()
  {
    Memory::reach(name_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<String> name_;
};

class NotExpr : public Expr
{
public:
  NotExpr(const SourcePos& pos, gc<Expr> value)
  : Expr(pos),
    value_(value)
  {}

  virtual void accept(ExprVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const NotExpr* asNotExpr() const { return this; }

  gc<Expr> value() const { return value_; }

  virtual void reach()
  {
    Memory::reach(value_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> value_;
};

class NothingExpr : public Expr
{
public:
  NothingExpr(const SourcePos& pos)
  : Expr(pos)
  {}

  virtual void accept(ExprVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const NothingExpr* asNothingExpr() const { return this; }


  virtual void trace(std::ostream& out) const;

private:
};

class NumberExpr : public Expr
{
public:
  NumberExpr(const SourcePos& pos, double value)
  : Expr(pos),
    value_(value)
  {}

  virtual void accept(ExprVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const NumberExpr* asNumberExpr() const { return this; }

  double value() const { return value_; }

  virtual void trace(std::ostream& out) const;

private:
  double value_;
};

class OrExpr : public Expr
{
public:
  OrExpr(const SourcePos& pos, gc<Expr> left, gc<Expr> right)
  : Expr(pos),
    left_(left),
    right_(right)
  {}

  virtual void accept(ExprVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const OrExpr* asOrExpr() const { return this; }

  gc<Expr> left() const { return left_; }
  gc<Expr> right() const { return right_; }

  virtual void reach()
  {
    Memory::reach(left_);
    Memory::reach(right_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> left_;
  gc<Expr> right_;
};

class RecordExpr : public Expr
{
public:
  RecordExpr(const SourcePos& pos, const Array<Field>& fields)
  : Expr(pos),
    fields_(fields)
  {}

  virtual void accept(ExprVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const RecordExpr* asRecordExpr() const { return this; }

  const Array<Field>& fields() const { return fields_; }

  virtual void reach()
  {

    for (int i = 0; i < fields_.count(); i++)
    {
        Memory::reach(fields_[i].name);
        Memory::reach(fields_[i].value);
    }
  }

  virtual void trace(std::ostream& out) const;

private:
  Array<Field> fields_;
};

class ReturnExpr : public Expr
{
public:
  ReturnExpr(const SourcePos& pos, gc<Expr> value)
  : Expr(pos),
    value_(value)
  {}

  virtual void accept(ExprVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const ReturnExpr* asReturnExpr() const { return this; }

  gc<Expr> value() const { return value_; }

  virtual void reach()
  {
    Memory::reach(value_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> value_;
};

class SequenceExpr : public Expr
{
public:
  SequenceExpr(const SourcePos& pos, const Array<gc<Expr> >& expressions)
  : Expr(pos),
    expressions_(expressions)
  {}

  virtual void accept(ExprVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const SequenceExpr* asSequenceExpr() const { return this; }

  const Array<gc<Expr> >& expressions() const { return expressions_; }

  virtual void reach()
  {
    Memory::reach(expressions_);
  }

  virtual void trace(std::ostream& out) const;

private:
  Array<gc<Expr> > expressions_;
};

class StringExpr : public Expr
{
public:
  StringExpr(const SourcePos& pos, gc<String> value)
  : Expr(pos),
    value_(value)
  {}

  virtual void accept(ExprVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const StringExpr* asStringExpr() const { return this; }

  gc<String> value() const { return value_; }

  virtual void reach()
  {
    Memory::reach(value_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<String> value_;
};

class ThrowExpr : public Expr
{
public:
  ThrowExpr(const SourcePos& pos, gc<Expr> value)
  : Expr(pos),
    value_(value)
  {}

  virtual void accept(ExprVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const ThrowExpr* asThrowExpr() const { return this; }

  gc<Expr> value() const { return value_; }

  virtual void reach()
  {
    Memory::reach(value_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> value_;
};

class VariableExpr : public Expr
{
public:
  VariableExpr(const SourcePos& pos, bool isMutable, gc<Pattern> pattern, gc<Expr> value)
  : Expr(pos),
    isMutable_(isMutable),
    pattern_(pattern),
    value_(value)
  {}

  virtual void accept(ExprVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const VariableExpr* asVariableExpr() const { return this; }

  bool isMutable() const { return isMutable_; }
  gc<Pattern> pattern() const { return pattern_; }
  gc<Expr> value() const { return value_; }

  virtual void reach()
  {
    Memory::reach(pattern_);
    Memory::reach(value_);
  }

  virtual void trace(std::ostream& out) const;

private:
  bool isMutable_;
  gc<Pattern> pattern_;
  gc<Expr> value_;
};

class PatternVisitor
{
public:
  virtual ~PatternVisitor() {}

  virtual void visit(const RecordPattern& node, int dest) = 0;
  virtual void visit(const TypePattern& node, int dest) = 0;
  virtual void visit(const ValuePattern& node, int dest) = 0;
  virtual void visit(const VariablePattern& node, int dest) = 0;
  virtual void visit(const WildcardPattern& node, int dest) = 0;

protected:
  PatternVisitor() {}

private:
  NO_COPY(PatternVisitor);
};

// Base class for all AST node classes.
class Pattern : public Managed
{
public:
  Pattern(const SourcePos& pos)
  : pos_(pos)
  {}

  virtual ~Pattern() {}

  // The visitor pattern.
  virtual void accept(PatternVisitor& visitor, int arg) const = 0;

  // Dynamic casts.
    virtual const RecordPattern* asRecordPattern() const { return NULL; }
  virtual const TypePattern* asTypePattern() const { return NULL; }
  virtual const ValuePattern* asValuePattern() const { return NULL; }
  virtual const VariablePattern* asVariablePattern() const { return NULL; }
  virtual const WildcardPattern* asWildcardPattern() const { return NULL; }

  const SourcePos& pos() const { return pos_; }

private:
  SourcePos pos_;
};

class RecordPattern : public Pattern
{
public:
  RecordPattern(const SourcePos& pos, const Array<PatternField>& fields)
  : Pattern(pos),
    fields_(fields)
  {}

  virtual void accept(PatternVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const RecordPattern* asRecordPattern() const { return this; }

  const Array<PatternField>& fields() const { return fields_; }

  virtual void reach()
  {

    for (int i = 0; i < fields_.count(); i++)
    {
        Memory::reach(fields_[i].name);
        Memory::reach(fields_[i].value);
    }
  }

  virtual void trace(std::ostream& out) const;

private:
  Array<PatternField> fields_;
};

class TypePattern : public Pattern
{
public:
  TypePattern(const SourcePos& pos, gc<Expr> type)
  : Pattern(pos),
    type_(type)
  {}

  virtual void accept(PatternVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const TypePattern* asTypePattern() const { return this; }

  gc<Expr> type() const { return type_; }

  virtual void reach()
  {
    Memory::reach(type_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> type_;
};

class ValuePattern : public Pattern
{
public:
  ValuePattern(const SourcePos& pos, gc<Expr> value)
  : Pattern(pos),
    value_(value)
  {}

  virtual void accept(PatternVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const ValuePattern* asValuePattern() const { return this; }

  gc<Expr> value() const { return value_; }

  virtual void reach()
  {
    Memory::reach(value_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> value_;
};

class VariablePattern : public Pattern
{
public:
  VariablePattern(const SourcePos& pos, gc<String> name, gc<Pattern> pattern)
  : Pattern(pos),
    name_(name),
    pattern_(pattern)
  {}

  virtual void accept(PatternVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const VariablePattern* asVariablePattern() const { return this; }

  gc<String> name() const { return name_; }
  gc<Pattern> pattern() const { return pattern_; }

  virtual void reach()
  {
    Memory::reach(name_);
    Memory::reach(pattern_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<String> name_;
  gc<Pattern> pattern_;
};

class WildcardPattern : public Pattern
{
public:
  WildcardPattern(const SourcePos& pos)
  : Pattern(pos)
  {}

  virtual void accept(PatternVisitor& visitor, int arg) const
  {
    visitor.visit(*this, arg);
  }

  virtual const WildcardPattern* asWildcardPattern() const { return this; }


  virtual void trace(std::ostream& out) const;

private:
};
