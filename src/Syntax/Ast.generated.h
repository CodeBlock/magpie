// Automatically generated by script/generate_ast.py.
// Do not hand-edit.

class MethodDef;
class AndExpr;
class AssignExpr;
class BinaryOpExpr;
class BoolExpr;
class CallExpr;
class CatchExpr;
class DoExpr;
class IfExpr;
class IsExpr;
class LoopExpr;
class MatchExpr;
class NameExpr;
class NotExpr;
class NothingExpr;
class NumberExpr;
class OrExpr;
class RecordExpr;
class ReturnExpr;
class SequenceExpr;
class StringExpr;
class ThrowExpr;
class VariableExpr;
class RecordPattern;
class TypePattern;
class ValuePattern;
class VariablePattern;
class WildcardPattern;

class DefVisitor
{
public:
  virtual ~DefVisitor() {}

  virtual void visit(MethodDef& node, int dest) = 0;

protected:
  DefVisitor() {}

private:
  NO_COPY(DefVisitor);
};

class Def : public Managed
{
public:
  Def(const SourcePos& pos)
  : pos_(pos)
  {}

  virtual ~Def() {}

  // The visitor pattern.
  virtual void accept(DefVisitor& visitor, int arg) = 0;

  // Dynamic casts.
  virtual MethodDef* asMethodDef() { return NULL; }

  const SourcePos& pos() const { return pos_; }

private:
  SourcePos pos_;
};

class MethodDef : public Def
{
public:
  MethodDef(const SourcePos& pos, gc<Pattern> leftParam, gc<String> name, gc<Pattern> rightParam, gc<Expr> body)
  : Def(pos),
    leftParam_(leftParam),
    name_(name),
    rightParam_(rightParam),
    body_(body),
    maxLocals_(-1)
  {}

  virtual void accept(DefVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual MethodDef* asMethodDef() { return this; }

  gc<Pattern> leftParam() const { return leftParam_; }
  gc<String> name() const { return name_; }
  gc<Pattern> rightParam() const { return rightParam_; }
  gc<Expr> body() const { return body_; }
  int maxLocals() const { return maxLocals_; }
  void setMaxLocals(int maxLocals) { maxLocals_ = maxLocals; }

  virtual void reach()
  {
    Memory::reach(leftParam_);
    Memory::reach(name_);
    Memory::reach(rightParam_);
    Memory::reach(body_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Pattern> leftParam_;
  gc<String> name_;
  gc<Pattern> rightParam_;
  gc<Expr> body_;
  int maxLocals_;
};

class ExprVisitor
{
public:
  virtual ~ExprVisitor() {}

  virtual void visit(AndExpr& node, int dest) = 0;
  virtual void visit(AssignExpr& node, int dest) = 0;
  virtual void visit(BinaryOpExpr& node, int dest) = 0;
  virtual void visit(BoolExpr& node, int dest) = 0;
  virtual void visit(CallExpr& node, int dest) = 0;
  virtual void visit(CatchExpr& node, int dest) = 0;
  virtual void visit(DoExpr& node, int dest) = 0;
  virtual void visit(IfExpr& node, int dest) = 0;
  virtual void visit(IsExpr& node, int dest) = 0;
  virtual void visit(LoopExpr& node, int dest) = 0;
  virtual void visit(MatchExpr& node, int dest) = 0;
  virtual void visit(NameExpr& node, int dest) = 0;
  virtual void visit(NotExpr& node, int dest) = 0;
  virtual void visit(NothingExpr& node, int dest) = 0;
  virtual void visit(NumberExpr& node, int dest) = 0;
  virtual void visit(OrExpr& node, int dest) = 0;
  virtual void visit(RecordExpr& node, int dest) = 0;
  virtual void visit(ReturnExpr& node, int dest) = 0;
  virtual void visit(SequenceExpr& node, int dest) = 0;
  virtual void visit(StringExpr& node, int dest) = 0;
  virtual void visit(ThrowExpr& node, int dest) = 0;
  virtual void visit(VariableExpr& node, int dest) = 0;

protected:
  ExprVisitor() {}

private:
  NO_COPY(ExprVisitor);
};

class Expr : public Managed
{
public:
  Expr(const SourcePos& pos)
  : pos_(pos)
  {}

  virtual ~Expr() {}

  // The visitor pattern.
  virtual void accept(ExprVisitor& visitor, int arg) = 0;

  // Dynamic casts.
  virtual AndExpr* asAndExpr() { return NULL; }
  virtual AssignExpr* asAssignExpr() { return NULL; }
  virtual BinaryOpExpr* asBinaryOpExpr() { return NULL; }
  virtual BoolExpr* asBoolExpr() { return NULL; }
  virtual CallExpr* asCallExpr() { return NULL; }
  virtual CatchExpr* asCatchExpr() { return NULL; }
  virtual DoExpr* asDoExpr() { return NULL; }
  virtual IfExpr* asIfExpr() { return NULL; }
  virtual IsExpr* asIsExpr() { return NULL; }
  virtual LoopExpr* asLoopExpr() { return NULL; }
  virtual MatchExpr* asMatchExpr() { return NULL; }
  virtual NameExpr* asNameExpr() { return NULL; }
  virtual NotExpr* asNotExpr() { return NULL; }
  virtual NothingExpr* asNothingExpr() { return NULL; }
  virtual NumberExpr* asNumberExpr() { return NULL; }
  virtual OrExpr* asOrExpr() { return NULL; }
  virtual RecordExpr* asRecordExpr() { return NULL; }
  virtual ReturnExpr* asReturnExpr() { return NULL; }
  virtual SequenceExpr* asSequenceExpr() { return NULL; }
  virtual StringExpr* asStringExpr() { return NULL; }
  virtual ThrowExpr* asThrowExpr() { return NULL; }
  virtual VariableExpr* asVariableExpr() { return NULL; }

  const SourcePos& pos() const { return pos_; }

private:
  SourcePos pos_;
};

class AndExpr : public Expr
{
public:
  AndExpr(const SourcePos& pos, gc<Expr> left, gc<Expr> right)
  : Expr(pos),
    left_(left),
    right_(right)
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual AndExpr* asAndExpr() { return this; }

  gc<Expr> left() const { return left_; }
  gc<Expr> right() const { return right_; }

  virtual void reach()
  {
    Memory::reach(left_);
    Memory::reach(right_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> left_;
  gc<Expr> right_;
};

class AssignExpr : public Expr
{
public:
  AssignExpr(const SourcePos& pos, gc<Pattern> pattern, gc<Expr> value)
  : Expr(pos),
    pattern_(pattern),
    value_(value)
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual AssignExpr* asAssignExpr() { return this; }

  gc<Pattern> pattern() const { return pattern_; }
  gc<Expr> value() const { return value_; }

  virtual void reach()
  {
    Memory::reach(pattern_);
    Memory::reach(value_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Pattern> pattern_;
  gc<Expr> value_;
};

class BinaryOpExpr : public Expr
{
public:
  BinaryOpExpr(const SourcePos& pos, gc<Expr> left, TokenType type, gc<Expr> right)
  : Expr(pos),
    left_(left),
    type_(type),
    right_(right)
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual BinaryOpExpr* asBinaryOpExpr() { return this; }

  gc<Expr> left() const { return left_; }
  TokenType type() const { return type_; }
  gc<Expr> right() const { return right_; }

  virtual void reach()
  {
    Memory::reach(left_);
    Memory::reach(right_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> left_;
  TokenType type_;
  gc<Expr> right_;
};

class BoolExpr : public Expr
{
public:
  BoolExpr(const SourcePos& pos, bool value)
  : Expr(pos),
    value_(value)
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual BoolExpr* asBoolExpr() { return this; }

  bool value() const { return value_; }

  virtual void trace(std::ostream& out) const;

private:
  bool value_;
};

class CallExpr : public Expr
{
public:
  CallExpr(const SourcePos& pos, gc<Expr> leftArg, gc<String> name, gc<Expr> rightArg)
  : Expr(pos),
    leftArg_(leftArg),
    name_(name),
    rightArg_(rightArg)
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual CallExpr* asCallExpr() { return this; }

  gc<Expr> leftArg() const { return leftArg_; }
  gc<String> name() const { return name_; }
  gc<Expr> rightArg() const { return rightArg_; }

  virtual void reach()
  {
    Memory::reach(leftArg_);
    Memory::reach(name_);
    Memory::reach(rightArg_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> leftArg_;
  gc<String> name_;
  gc<Expr> rightArg_;
};

class CatchExpr : public Expr
{
public:
  CatchExpr(const SourcePos& pos, gc<Expr> body, const Array<MatchClause>& catches)
  : Expr(pos),
    body_(body),
    catches_(catches)
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual CatchExpr* asCatchExpr() { return this; }

  gc<Expr> body() const { return body_; }
  const Array<MatchClause>& catches() { return catches_; }

  virtual void reach()
  {
    Memory::reach(body_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> body_;
  Array<MatchClause> catches_;
};

class DoExpr : public Expr
{
public:
  DoExpr(const SourcePos& pos, gc<Expr> body)
  : Expr(pos),
    body_(body)
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual DoExpr* asDoExpr() { return this; }

  gc<Expr> body() const { return body_; }

  virtual void reach()
  {
    Memory::reach(body_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> body_;
};

class IfExpr : public Expr
{
public:
  IfExpr(const SourcePos& pos, gc<Expr> condition, gc<Expr> thenArm, gc<Expr> elseArm)
  : Expr(pos),
    condition_(condition),
    thenArm_(thenArm),
    elseArm_(elseArm)
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual IfExpr* asIfExpr() { return this; }

  gc<Expr> condition() const { return condition_; }
  gc<Expr> thenArm() const { return thenArm_; }
  gc<Expr> elseArm() const { return elseArm_; }

  virtual void reach()
  {
    Memory::reach(condition_);
    Memory::reach(thenArm_);
    Memory::reach(elseArm_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> condition_;
  gc<Expr> thenArm_;
  gc<Expr> elseArm_;
};

class IsExpr : public Expr
{
public:
  IsExpr(const SourcePos& pos, gc<Expr> value, gc<Expr> type)
  : Expr(pos),
    value_(value),
    type_(type)
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual IsExpr* asIsExpr() { return this; }

  gc<Expr> value() const { return value_; }
  gc<Expr> type() const { return type_; }

  virtual void reach()
  {
    Memory::reach(value_);
    Memory::reach(type_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> value_;
  gc<Expr> type_;
};

class LoopExpr : public Expr
{
public:
  LoopExpr(const SourcePos& pos, const Array<LoopClause>& clauses, gc<Expr> body)
  : Expr(pos),
    clauses_(clauses),
    body_(body)
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual LoopExpr* asLoopExpr() { return this; }

  const Array<LoopClause>& clauses() { return clauses_; }
  gc<Expr> body() const { return body_; }

  virtual void reach()
  {
    Memory::reach(body_);
  }

  virtual void trace(std::ostream& out) const;

private:
  Array<LoopClause> clauses_;
  gc<Expr> body_;
};

class MatchExpr : public Expr
{
public:
  MatchExpr(const SourcePos& pos, gc<Expr> value, const Array<MatchClause>& cases)
  : Expr(pos),
    value_(value),
    cases_(cases)
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual MatchExpr* asMatchExpr() { return this; }

  gc<Expr> value() const { return value_; }
  const Array<MatchClause>& cases() { return cases_; }

  virtual void reach()
  {
    Memory::reach(value_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> value_;
  Array<MatchClause> cases_;
};

class NameExpr : public Expr
{
public:
  NameExpr(const SourcePos& pos, gc<String> name)
  : Expr(pos),
    name_(name),
    resolved_()
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual NameExpr* asNameExpr() { return this; }

  gc<String> name() const { return name_; }
  ResolvedName resolved() const { return resolved_; }
  void setResolved(ResolvedName resolved) { resolved_ = resolved; }

  virtual void reach()
  {
    Memory::reach(name_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<String> name_;
  ResolvedName resolved_;
};

class NotExpr : public Expr
{
public:
  NotExpr(const SourcePos& pos, gc<Expr> value)
  : Expr(pos),
    value_(value)
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual NotExpr* asNotExpr() { return this; }

  gc<Expr> value() const { return value_; }

  virtual void reach()
  {
    Memory::reach(value_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> value_;
};

class NothingExpr : public Expr
{
public:
  NothingExpr(const SourcePos& pos)
  : Expr(pos)
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual NothingExpr* asNothingExpr() { return this; }


  virtual void trace(std::ostream& out) const;

private:
};

class NumberExpr : public Expr
{
public:
  NumberExpr(const SourcePos& pos, double value)
  : Expr(pos),
    value_(value)
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual NumberExpr* asNumberExpr() { return this; }

  double value() const { return value_; }

  virtual void trace(std::ostream& out) const;

private:
  double value_;
};

class OrExpr : public Expr
{
public:
  OrExpr(const SourcePos& pos, gc<Expr> left, gc<Expr> right)
  : Expr(pos),
    left_(left),
    right_(right)
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual OrExpr* asOrExpr() { return this; }

  gc<Expr> left() const { return left_; }
  gc<Expr> right() const { return right_; }

  virtual void reach()
  {
    Memory::reach(left_);
    Memory::reach(right_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> left_;
  gc<Expr> right_;
};

class RecordExpr : public Expr
{
public:
  RecordExpr(const SourcePos& pos, const Array<Field>& fields)
  : Expr(pos),
    fields_(fields)
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual RecordExpr* asRecordExpr() { return this; }

  const Array<Field>& fields() { return fields_; }

  virtual void reach()
  {

    for (int i = 0; i < fields_.count(); i++)
    {
        Memory::reach(fields_[i].name);
        Memory::reach(fields_[i].value);
    }
  }

  virtual void trace(std::ostream& out) const;

private:
  Array<Field> fields_;
};

class ReturnExpr : public Expr
{
public:
  ReturnExpr(const SourcePos& pos, gc<Expr> value)
  : Expr(pos),
    value_(value)
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual ReturnExpr* asReturnExpr() { return this; }

  gc<Expr> value() const { return value_; }

  virtual void reach()
  {
    Memory::reach(value_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> value_;
};

class SequenceExpr : public Expr
{
public:
  SequenceExpr(const SourcePos& pos, const Array<gc<Expr> >& expressions)
  : Expr(pos),
    expressions_(expressions)
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual SequenceExpr* asSequenceExpr() { return this; }

  const Array<gc<Expr> >& expressions() { return expressions_; }

  virtual void reach()
  {
    Memory::reach(expressions_);
  }

  virtual void trace(std::ostream& out) const;

private:
  Array<gc<Expr> > expressions_;
};

class StringExpr : public Expr
{
public:
  StringExpr(const SourcePos& pos, gc<String> value)
  : Expr(pos),
    value_(value)
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual StringExpr* asStringExpr() { return this; }

  gc<String> value() const { return value_; }

  virtual void reach()
  {
    Memory::reach(value_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<String> value_;
};

class ThrowExpr : public Expr
{
public:
  ThrowExpr(const SourcePos& pos, gc<Expr> value)
  : Expr(pos),
    value_(value)
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual ThrowExpr* asThrowExpr() { return this; }

  gc<Expr> value() const { return value_; }

  virtual void reach()
  {
    Memory::reach(value_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> value_;
};

class VariableExpr : public Expr
{
public:
  VariableExpr(const SourcePos& pos, bool isMutable, gc<Pattern> pattern, gc<Expr> value)
  : Expr(pos),
    isMutable_(isMutable),
    pattern_(pattern),
    value_(value)
  {}

  virtual void accept(ExprVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual VariableExpr* asVariableExpr() { return this; }

  bool isMutable() const { return isMutable_; }
  gc<Pattern> pattern() const { return pattern_; }
  gc<Expr> value() const { return value_; }

  virtual void reach()
  {
    Memory::reach(pattern_);
    Memory::reach(value_);
  }

  virtual void trace(std::ostream& out) const;

private:
  bool isMutable_;
  gc<Pattern> pattern_;
  gc<Expr> value_;
};

class PatternVisitor
{
public:
  virtual ~PatternVisitor() {}

  virtual void visit(RecordPattern& node, int dest) = 0;
  virtual void visit(TypePattern& node, int dest) = 0;
  virtual void visit(ValuePattern& node, int dest) = 0;
  virtual void visit(VariablePattern& node, int dest) = 0;
  virtual void visit(WildcardPattern& node, int dest) = 0;

protected:
  PatternVisitor() {}

private:
  NO_COPY(PatternVisitor);
};

class Pattern : public Managed
{
public:
  Pattern(const SourcePos& pos)
  : pos_(pos)
  {}

  virtual ~Pattern() {}

  // The visitor pattern.
  virtual void accept(PatternVisitor& visitor, int arg) = 0;

  // Dynamic casts.
  virtual RecordPattern* asRecordPattern() { return NULL; }
  virtual TypePattern* asTypePattern() { return NULL; }
  virtual ValuePattern* asValuePattern() { return NULL; }
  virtual VariablePattern* asVariablePattern() { return NULL; }
  virtual WildcardPattern* asWildcardPattern() { return NULL; }

  const SourcePos& pos() const { return pos_; }

private:
  SourcePos pos_;
};

class RecordPattern : public Pattern
{
public:
  RecordPattern(const SourcePos& pos, const Array<PatternField>& fields)
  : Pattern(pos),
    fields_(fields)
  {}

  virtual void accept(PatternVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual RecordPattern* asRecordPattern() { return this; }

  const Array<PatternField>& fields() { return fields_; }

  virtual void reach()
  {

    for (int i = 0; i < fields_.count(); i++)
    {
        Memory::reach(fields_[i].name);
        Memory::reach(fields_[i].value);
    }
  }

  virtual void trace(std::ostream& out) const;

private:
  Array<PatternField> fields_;
};

class TypePattern : public Pattern
{
public:
  TypePattern(const SourcePos& pos, gc<Expr> type)
  : Pattern(pos),
    type_(type)
  {}

  virtual void accept(PatternVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual TypePattern* asTypePattern() { return this; }

  gc<Expr> type() const { return type_; }

  virtual void reach()
  {
    Memory::reach(type_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> type_;
};

class ValuePattern : public Pattern
{
public:
  ValuePattern(const SourcePos& pos, gc<Expr> value)
  : Pattern(pos),
    value_(value)
  {}

  virtual void accept(PatternVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual ValuePattern* asValuePattern() { return this; }

  gc<Expr> value() const { return value_; }

  virtual void reach()
  {
    Memory::reach(value_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<Expr> value_;
};

class VariablePattern : public Pattern
{
public:
  VariablePattern(const SourcePos& pos, gc<String> name, gc<Pattern> pattern)
  : Pattern(pos),
    name_(name),
    pattern_(pattern),
    resolved_()
  {}

  virtual void accept(PatternVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual VariablePattern* asVariablePattern() { return this; }

  gc<String> name() const { return name_; }
  gc<Pattern> pattern() const { return pattern_; }
  ResolvedName resolved() const { return resolved_; }
  void setResolved(ResolvedName resolved) { resolved_ = resolved; }

  virtual void reach()
  {
    Memory::reach(name_);
    Memory::reach(pattern_);
  }

  virtual void trace(std::ostream& out) const;

private:
  gc<String> name_;
  gc<Pattern> pattern_;
  ResolvedName resolved_;
};

class WildcardPattern : public Pattern
{
public:
  WildcardPattern(const SourcePos& pos)
  : Pattern(pos)
  {}

  virtual void accept(PatternVisitor& visitor, int arg)
  {
    visitor.visit(*this, arg);
  }

  virtual WildcardPattern* asWildcardPattern() { return this; }


  virtual void trace(std::ostream& out) const;

private:
};
