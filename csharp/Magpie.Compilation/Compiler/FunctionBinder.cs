using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Magpie.Compilation
{
    /// <summary>
    /// Generates a bound function body where all names have been resolved.
    /// </summary>
    public class FunctionBinder : IUnboundExprVisitor<IBoundExpr>
    {
        public static BoundFunction Bind(CompileUnit unit, Function function, Function instancingContext)
        {
            var scope = new Scope();

            // create locals for all of the arguments
            foreach (ParamDecl arg in function.FuncType.Parameters)
            {
                scope.Define(arg.Name, arg.Type, false);
            }

            var uniqueName = BoundFunction.GetUniqueName(function.FullName, function.TypeParameters, function.FuncType.ParameterTypes);
            var inferredName = String.Empty;

            if (function.CanOmitTypeArgs)
            {
                inferredName = BoundFunction.GetUniqueName(function.FullName, null, function.FuncType.ParameterTypes);
            }

            // add it to the collection before actually binding the body, in case the body is
            // recursive, so it can find references to itself in the collection of bound functions
            var bound = new BoundFunction(uniqueName, inferredName, function.FuncType, scope);
            unit.AddBound(bound);

            var binder = new FunctionBinder(function, instancingContext, unit, scope);
            bound.SetBody(function.Body.Accept<IBoundExpr>(binder));

            // make sure declared return type matches actual return type
            // ignore wrap bound expressions. those are used for the autogenerated functions from types
            // since types aren't instantiated for generics, the expr type will be wrong
            if (!(function.Body is WrapBoundExpr) && !DeclComparer.Equals(bound.Type.Return, bound.Body.Type))
            {
                throw new CompileException(String.Format("{0} is declared to return {1} but is returning {2}.",
                    bound.Name, bound.Type.Return, bound.Body.Type));
            }

            return bound;
        }

        #region IUnboundExprVisitor<IBoundExpr> Members

        public IBoundExpr Visit(CallExpr expr)
        {
            IBoundExpr boundArg = expr.Arg.Accept(this);

            NameExpr namedTarget = expr.Target as NameExpr;
            if (namedTarget != null)
            {
                return mUnit.ResolveName(mFunction, mInstancingContext, Scope, namedTarget.Name, namedTarget.TypeArgs, boundArg);
            }

            IBoundExpr target = expr.Target.Accept(this);

            if (!(target.Type is FuncType)) throw new CompileException("Target of an application must be a function.");

            // check that args match
            FuncType funcType = (FuncType)target.Type;
            if (!DeclComparer.Equals(funcType.ParameterTypes, boundArg.Type.Expanded))
            {
                throw new CompileException("Argument types passed to evaluated function reference do not match function's parameter types.");
            }

            // simply apply the arg to the bound expression
            return new BoundCallExpr(target, boundArg);
        }

        public IBoundExpr Visit(ArrayExpr expr)
        {
            Decl elementType = expr.ElementType;
            IEnumerable<IBoundExpr> elements = expr.Elements.Accept(this);

            // infer the type from the elements
            if (elementType == null)
            {
                int index = 0;
                foreach (var element in elements)
                {
                    if (elementType == null)
                    {
                        // take the type of the first
                        elementType = element.Type;
                    }
                    else
                    {
                        // make sure the others match
                        if (!DeclComparer.Equals(elementType, element.Type))
                            throw new CompileException(String.Format("Array elements must all be the same type. Array is type {0}, but element {1} is type {2}.",
                                elementType, index, element.Type));
                    }

                    index++;
                }
            }

            //### bob: need to check all elements are the same type
            return new BoundArrayExpr(elementType, elements);
        }

        public IBoundExpr Visit(AssignExpr expr)
        {
            IBoundExpr value = expr.Value.Accept(this);

            // handle a name target: foo <- 3
            NameExpr nameTarget = expr.Target as NameExpr;
            if (nameTarget != null)
            {
                // see if it's a local
                if (Scope.Contains(nameTarget.Name))
                {
                    if (!Scope[nameTarget.Name].IsMutable) throw new CompileException("Cannot assign to immutable local.");

                    // direct assign to local
                    return new StoreExpr(new LocalsExpr(), Scope[nameTarget.Name], value);
                }

                // look for an assignment function
                return TranslateAssignment(nameTarget.Name, nameTarget.TypeArgs, new UnitExpr(), value);
            }

            // handle a function apply target: Foo 1 <- 3  ==> Foo<- (1, 3)
            CallExpr applyTarget = expr.Target as CallExpr;
            if (applyTarget != null)
            {
                // make sure it's a direct function call
                NameExpr funcName = applyTarget.Target as NameExpr;
                if (funcName == null) throw new CompileException("Application target on left-hand side of an assignment must be a named function.");

                // translate the call
                IBoundExpr applyArg = applyTarget.Arg.Accept(this);
                return TranslateAssignment(funcName.Name, funcName.TypeArgs, applyArg, value);
            }

            // handle an operator target: 1 $$ 2 <- 3  ==> assign@$$ (1, 2, 3)
            OperatorExpr operatorTarget = expr.Target as OperatorExpr;
            if (operatorTarget != null)
            {
                IBoundExpr opArg = new BoundTupleExpr(new IBoundExpr[]
                    { operatorTarget.Left.Accept(this),
                      operatorTarget.Right.Accept(this) });

                return TranslateAssignment(operatorTarget.Name, null /* no operator generics yet */, opArg, value);
            }

            TupleExpr tupleTarget = expr.Target as TupleExpr;
            if (tupleTarget != null)
            {
                //### bob: need to handle tuple decomposition here:
                //         a, b <- (1, 2)
                throw new NotImplementedException();
            }

            // if we got here, it's not a valid assignment expression
            throw new CompileException("Cannot assign to " + expr.Target);
        }

        public IBoundExpr Visit(BlockExpr block)
        {
            //### bob: still need to implement block scope
            List<IBoundExpr> exprs = new List<IBoundExpr>();
            int index = 0;
            foreach (IUnboundExpr expr in block.Exprs)
            {
                IBoundExpr bound = expr.Accept(this);

                // all but last expression must be void
                if (index < block.Exprs.Count - 1)
                {
                    if (bound.Type != Decl.Unit)
                        throw new CompileException("All expressions in a block except the last must be of type Unit. " + block.ToString());
                }

                index++;

                exprs.Add(bound);
            }

            return new BoundBlockExpr(exprs);
        }

        public IBoundExpr Visit(DefineExpr expr)
        {
            if (Scope.Contains(expr.Name)) throw new CompileException("A local variable named \"" + expr.Name + "\" is already defined in this scope.");

            IBoundExpr value = expr.Value.Accept(this);

            // add it to the scope
            Scope.Define(expr.Name, value.Type, expr.IsMutable);

            // assign it
            return new StoreExpr(new LocalsExpr(), Scope[expr.Name], value);
        }

        public IBoundExpr Visit(FuncRefExpr expr)
        {
            BoundFunction function = mUnit.ResolveFunction(mFunction, mInstancingContext, Scope, expr.Name.Name, expr.Name.TypeArgs, expr.ParamTypes);
            return new BoundFuncRefExpr(function);
        }

        public IBoundExpr Visit(IfDoExpr expr)
        {
            var bound = new BoundIfDoExpr(
                expr.Condition.Accept(this),
                expr.Body.Accept(this));

            if (bound.Body.Type != Decl.Unit)
            {
                throw new CompileException(String.Format(
                    "Body of if/do is returning type {0} but should be void.",
                    bound.Body.Type));
            }

            return bound;
        }

        public IBoundExpr Visit(IfThenExpr expr)
        {
            var bound = new BoundIfThenExpr(
                expr.Condition.Accept(this),
                expr.ThenBody.Accept(this),
                expr.ElseBody.Accept(this));

            if (!DeclComparer.Equals(bound.ThenBody.Type, bound.ElseBody.Type))
            {
                throw new CompileException(String.Format(
                    "Arms of if/then/else to not return the same type. Then arm returns {0} while else arm returns {1}.",
                    bound.ThenBody.Type, bound.ElseBody.Type));
            }

            return bound;
        }

        public IBoundExpr Visit(NameExpr expr)
        {
            return mUnit.ResolveName(mFunction, mInstancingContext, Scope, expr.Name, expr.TypeArgs, null);
        }

        public IBoundExpr Visit(OperatorExpr expr)
        {
            // an operator is just function application
            CallExpr apply = new CallExpr(new NameExpr(expr.Name), new TupleExpr(new IUnboundExpr[] { expr.Left, expr.Right }));

            return apply.Accept(this);
        }

        public IBoundExpr Visit(TupleExpr expr)
        {
            return new BoundTupleExpr(expr.Fields.Accept(this));
        }

        public IBoundExpr Visit(IntExpr expr)
        {
            return expr;
        }

        public IBoundExpr Visit(BoolExpr expr)
        {
            return expr;
        }

        public IBoundExpr Visit(StringExpr expr)
        {
            return expr;
        }

        public IBoundExpr Visit(UnitExpr expr)
        {
            return expr;
        }

        public IBoundExpr Visit(WhileExpr expr)
        {
            var bound = new BoundWhileExpr(expr.Condition.Accept(this), expr.Body.Accept(this));

            if (bound.Condition.Type != Decl.Bool)
            {
                throw new CompileException(String.Format(
                    "Condition of while/do is returning type {0} but should be Bool.",
                    bound.Body.Type));
            }

            if (bound.Body.Type != Decl.Unit)
            {
                throw new CompileException(String.Format(
                    "Body of while/do is returning type {0} but should be Unit.",
                    bound.Body.Type));
            }

            return bound;
        }

        public IBoundExpr Visit(ConstructUnionExpr expr)
        {
            return expr;
        }

        public IBoundExpr Visit(WrapBoundExpr expr)
        {
            // unwrap it
            return expr.Bound;
        }

        #endregion

        private IBoundExpr TranslateAssignment(string baseName, IList<Decl> typeArgs, IBoundExpr arg, IBoundExpr value)
        {
            string name = baseName + "<-";

            // add the value argument
            arg = mUnit.AppendArg(arg, value);

            return mUnit.ResolveName(mFunction, mInstancingContext, Scope, name, typeArgs, arg);
        }

        private FunctionBinder(Function function, Function instancingContext, CompileUnit unit, Scope scope)
        {
            mFunction = function;
            mInstancingContext = instancingContext;
            mUnit = unit;
            mScope = scope;
        }

        //### bob: when there's block scope, this may need to change
        private Scope Scope { get { return mScope; } }

        private Function mFunction;
        private Function mInstancingContext;
        private CompileUnit mUnit;
        private Scope mScope;
    }
}
